#!/usr/bin/env python3

import sys
import copy

INF = float('inf')

class Router:
    def __init__(self, name, all_routers):
        self.name = name
        self.all_routers = sorted(all_routers)
        self.neighbors = {}  # direct neighbors and their costs
        self.distance_table = {}  # distance_table[dest][via] = cost
        self.routing_table = {}  # destination -> (next_hop, cost)
        self.has_updates = False
        
        # Initialize distance table
        for dest in self.all_routers:
            if dest != self.name:
                self.distance_table[dest] = {}
                for via in self.all_routers:
                    if via != self.name:
                        self.distance_table[dest][via] = INF
    
    def update_topology(self, graph):
        """Update direct neighbors from graph"""
        old_neighbors = set(self.neighbors.keys())
        self.neighbors = {}
        
        if self.name in graph:
            for neighbor, cost in graph[self.name].items():
                self.neighbors[neighbor] = cost
                # Update distance table for direct connections
                if neighbor in self.distance_table:
                    self.distance_table[neighbor][neighbor] = cost
        
        # Mark removed neighbors as unreachable
        new_neighbors = set(self.neighbors.keys())
        removed_neighbors = old_neighbors - new_neighbors
        
        for neighbor in removed_neighbors:
            if neighbor in self.distance_table:
                self.distance_table[neighbor][neighbor] = INF
        
        # Check if we need to send updates
        if old_neighbors != new_neighbors:
            self.has_updates = True
    
    def get_distance_vector(self):
        """Get current distance vector (minimum costs to all destinations)"""
        distance_vector = {}
        for dest in self.all_routers:
            if dest != self.name:
                min_cost = INF
                for via in self.all_routers:
                    if via != self.name and dest in self.distance_table:
                        if self.distance_table[dest][via] < min_cost:
                            min_cost = self.distance_table[dest][via]
                distance_vector[dest] = min_cost
        return distance_vector
    
    def process_distance_vector(self, from_router, received_dv):
        """Process received distance vector from neighbor"""
        if from_router not in self.neighbors:
            return  # Not a direct neighbor
        
        old_table = copy.deepcopy(self.distance_table)
        direct_cost = self.neighbors[from_router]
        
        # Update distance table using Bellman-Ford equation
        for dest in received_dv:
            if dest != self.name and dest in self.distance_table:
                new_cost = direct_cost + received_dv[dest]
                if new_cost < self.distance_table[dest][from_router]:
                    self.distance_table[dest][from_router] = new_cost
                    self.has_updates = True
                elif self.distance_table[dest][from_router] != new_cost:
                    self.distance_table[dest][from_router] = new_cost
                    self.has_updates = True
    
    def update_routing_table(self):
        """Update routing table based on current distance table"""
        self.routing_table = {}
        for dest in self.all_routers:
            if dest != self.name:
                min_cost = INF
                best_next_hop = None
                
                # Find minimum cost path
                for via in sorted(self.all_routers):  # Alphabetical order for tie-breaking
                    if via != self.name and dest in self.distance_table:
                        if self.distance_table[dest][via] < min_cost:
                            min_cost = self.distance_table[dest][via]
                            best_next_hop = via
                
                if min_cost == INF:
                    self.routing_table[dest] = ("INF", "INF")
                else:
                    self.routing_table[dest] = (best_next_hop, min_cost)
    
    def print_distance_table(self, t):
        """Print distance table in required format"""
        print(f"Distance Table of router {self.name} at t={t}:")
        
        # Header
        destinations = [d for d in self.all_routers if d != self.name]
        print("    " + "   ".join(destinations))
        
        # Rows
        for via in destinations:
            row = [via]
            for dest in destinations:
                if dest in self.distance_table and via in self.distance_table[dest]:
                    cost = self.distance_table[dest][via]
                    if cost == INF:
                        row.append("INF")
                    else:
                        row.append(str(int(cost)))
                else:
                    row.append("INF")
            print("   ".join(row))
        print()
    
    def print_routing_table(self):
        """Print routing table in required format"""
        print(f"Routing Table of router {self.name}:")
        for dest in sorted(self.routing_table.keys()):
            next_hop, cost = self.routing_table[dest]
            if cost == "INF":
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{next_hop},{int(cost)}")
        print()

def parse_input():
    """Parse input and return initial topology"""
    routers = []
    graph = {}
    
    # Read router names
    while True:
        line = input().strip()
        if line == "START":
            break
        routers.append(line)
        graph[line] = {}
    
    # Read initial topology
    while True:
        line = input().strip()
        if line == "UPDATE":
            break
        parts = line.split()
        node1, node2, weight = parts[0], parts[1], int(parts[2])
        
        if node1 not in graph:
            graph[node1] = {}
        if node2 not in graph:
            graph[node2] = {}
            
        if weight == -1:
            # Remove edge
            if node2 in graph[node1]:
                del graph[node1][node2]
            if node1 in graph[node2]:
                del graph[node2][node1]
        else:
            graph[node1][node2] = weight
            graph[node2][node1] = weight
    
    return routers, graph

def run_distance_vector(routers_list, graph):
    """Run the distance vector algorithm until convergence"""
    # Initialize routers
    routers = {}
    for name in routers_list:
        routers[name] = Router(name, routers_list)
        routers[name].update_topology(graph)
    
    t = 0
    
    # Print initial distance tables
    for name in sorted(routers_list):
        routers[name].print_distance_table(t)
    
    # Run algorithm until convergence
    while True:
        t += 1
        
        # All routers send their distance vectors
        updates = {}
        for name in routers_list:
            if routers[name].has_updates or t == 1:
                updates[name] = routers[name].get_distance_vector()
        
        if not updates:
            break
        
        # All routers process received updates
        any_changes = False
        for name in routers_list:
            routers[name].has_updates = False
            for sender, dv in updates.items():
                if sender != name:
                    routers[name].process_distance_vector(sender, dv)
            if routers[name].has_updates:
                any_changes = True
        
        if not any_changes:
            break
        
        # Print distance tables
        for name in sorted(routers_list):
            routers[name].print_distance_table(t)
    
    # Print final routing tables
    for name in sorted(routers_list):
        routers[name].update_routing_table()
        routers[name].print_routing_table()
    
    return routers

def main():
    routers_list, graph = parse_input()
    routers = run_distance_vector(routers_list, graph)
    
    # Process updates
    updates = []
    while True:
        try:
            line = input().strip()
            if line == "END":
                break
            updates.append(line)
        except EOFError:
            break
    
    if updates:
        # Apply updates to graph
        for update in updates:
            parts = update.split()
            node1, node2, weight = parts[0], parts[1], int(parts[2])
            
            if node1 not in graph:
                graph[node1] = {}
                if node1 not in routers_list:
                    routers_list.append(node1)
            if node2 not in graph:
                graph[node2] = {}
                if node2 not in routers_list:
                    routers_list.append(node2)
            
            if weight == -1:
                if node2 in graph[node1]:
                    del graph[node1][node2]
                if node1 in graph[node2]:
                    del graph[node2][node1]
            else:
                graph[node1][node2] = weight
                graph[node2][node1] = weight
        
        # Run algorithm again with updated topology
        run_distance_vector(routers_list, graph)

if __name__ == "__main__":
    main()
