#!/usr/bin/env python3

import sys
import copy

class Router:
    def __init__(self, name):
        self.name = name
        self.neighbors = {}  # direct neighbors and their costs
        self.distance_table = {}  # distance_table[dest][via] = cost
        self.routing_table = {}  # routing_table[dest] = (next_hop, cost)
        self.received_updates = []
        
    def initialize_distance_table(self, all_routers):
        """Initialize distance table with all destinations except self"""
        destinations = [r for r in all_routers if r != self.name]
        for dest in destinations:
            self.distance_table[dest] = {}
            for via in destinations:
                self.distance_table[dest][via] = float('inf')
    
    def update_direct_neighbors(self, graph):
        """Update distance table with direct neighbor costs"""
        self.neighbors = graph.get(self.name, {}).copy()
        
        # Update distance table for direct neighbors
        for dest in self.distance_table:
            if dest in self.neighbors:
                self.distance_table[dest][dest] = self.neighbors[dest]
            else:
                # Set to infinity if no direct connection
                self.distance_table[dest][dest] = float('inf')
    
    def send_distance_vector(self, all_routers):
        """Send distance vector to all neighbors"""
        updates = []
        for neighbor in self.neighbors:
            # Create distance vector (minimum costs to each destination)
            distance_vector = {}
            for dest in self.distance_table:
                min_cost = min(self.distance_table[dest].values())
                distance_vector[dest] = min_cost
            
            updates.append((neighbor, self.name, distance_vector))
        return updates
    
    def receive_update(self, from_router, distance_vector):
        """Receive distance vector from a neighbor"""
        self.received_updates.append((from_router, distance_vector))
    
    def process_updates(self):
        """Process all received updates and update distance table"""
        changed = False
        
        for from_router, distance_vector in self.received_updates:
            if from_router not in self.neighbors:
                continue
                
            cost_to_neighbor = self.neighbors[from_router]
            
            # Update distance table
            for dest in distance_vector:
                if dest == self.name:
                    continue
                    
                new_cost = cost_to_neighbor + distance_vector[dest]
                old_cost = self.distance_table[dest].get(from_router, float('inf'))
                
                if new_cost != old_cost:
                    self.distance_table[dest][from_router] = new_cost
                    changed = True
        
        self.received_updates = []
        return changed
    
    def update_routing_table(self):
        """Update routing table based on current distance table"""
        self.routing_table = {}
        
        for dest in self.distance_table:
            min_cost = float('inf')
            best_next_hop = None
            
            # Find the best next hop (minimum cost, then alphabetical)
            for via in sorted(self.distance_table[dest].keys()):
                cost = self.distance_table[dest][via]
                if cost < min_cost:
                    min_cost = cost
                    best_next_hop = via
            
            if min_cost == float('inf'):
                self.routing_table[dest] = ('INF', 'INF')
            else:
                self.routing_table[dest] = (best_next_hop, min_cost)
    
    def print_distance_table(self, t):
        """Print distance table in required format"""
        destinations = sorted(self.distance_table.keys())
        
        print(f"Distance Table of router {self.name} at t={t}:")
        
        # Header
        header = "  " + "   ".join(destinations)
        print(header)
        
        # Rows
        for dest in destinations:
            row = dest + " "
            for via in destinations:
                cost = self.distance_table[dest][via]
                cost_str = "INF" if cost == float('inf') else str(int(cost))
                row += cost_str + "   "
            print(row.rstrip())
        print()
    
    def print_routing_table(self):
        """Print routing table in required format"""
        print(f"Routing Table of router {self.name}:")
        
        for dest in sorted(self.routing_table.keys()):
            next_hop, cost = self.routing_table[dest]
            if cost == 'INF':
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{next_hop},{int(cost)}")
        print()

def read_input():
    """Read and parse input"""
    routers = []
    
    # Read router names
    while True:
        line = input().strip()
        if line == "START":
            break
        routers.append(line)
    
    # Read initial topology
    graph = {}
    while True:
        line = input().strip()
        if line == "UPDATE":
            break
        
        parts = line.split()
        router1, router2, weight = parts[0], parts[1], int(parts[2])
        
        if router1 not in graph:
            graph[router1] = {}
        if router2 not in graph:
            graph[router2] = {}
        
        if weight == -1:
            # Remove edge
            graph[router1].pop(router2, None)
            graph[router2].pop(router1, None)
        else:
            # Add edge
            graph[router1][router2] = weight
            graph[router2][router1] = weight
    
    # Read updates
    updates = []
    while True:
        line = input().strip()
        if line == "END":
            break
        
        parts = line.split()
        router1, router2, weight = parts[0], parts[1], int(parts[2])
        updates.append((router1, router2, weight))
    
    return routers, graph, updates

def run_distance_vector(routers, graph):
    """Run distance vector algorithm until convergence"""
    router_objects = {}
    
    # Create router objects
    for name in routers:
        router_objects[name] = Router(name)
        router_objects[name].initialize_distance_table(routers)
        router_objects[name].update_direct_neighbors(graph)
    
    t = 0
    
    # Print initial distance tables
    for name in sorted(routers):
        router_objects[name].print_distance_table(t)
    
    # Run until convergence
    while True:
        t += 1
        
        # Collect all updates
        all_updates = []
        for name in sorted(routers):
            updates = router_objects[name].send_distance_vector(routers)
            all_updates.extend(updates)
        
        # Deliver updates
        for neighbor, sender, distance_vector in all_updates:
            if neighbor in router_objects:
                router_objects[neighbor].receive_update(sender, distance_vector)
        
        # Process updates
        any_changed = False
        for name in routers:
            changed = router_objects[name].process_updates()
            if changed:
                any_changed = True
        
        if not any_changed:
            break
        
        # Print distance tables
        for name in sorted(routers):
            router_objects[name].print_distance_table(t)
    
    # Update and print routing tables
    for name in sorted(routers):
        router_objects[name].update_routing_table()
        router_objects[name].print_routing_table()
    
    return router_objects

def apply_updates(router_objects, graph, updates):
    """Apply topology updates and re-run algorithm"""
    # Apply updates to graph
    for router1, router2, weight in updates:
        if router1 not in graph:
            graph[router1] = {}
        if router2 not in graph:
            graph[router2] = {}
        
        if weight == -1:
            # Remove edge
            graph[router1].pop(router2, None)
            graph[router2].pop(router1, None)
        else:
            # Add/update edge
            graph[router1][router2] = weight
            graph[router2][router1] = weight
    
    # Update router neighbor information
    for name, router in router_objects.items():
        router.update_direct_neighbors(graph)
    
    # Re-run distance vector algorithm
    routers = sorted(router_objects.keys())
    t = 0
    
    # Print initial distance tables after update
    for name in routers:
        router_objects[name].print_distance_table(t)
    
    # Run until convergence
    while True:
        t += 1
        
        # Collect all updates
        all_updates = []
        for name in routers:
            updates = router_objects[name].send_distance_vector(routers)
            all_updates.extend(updates)
        
        # Deliver updates
        for neighbor, sender, distance_vector in all_updates:
            if neighbor in router_objects:
                router_objects[neighbor].receive_update(sender, distance_vector)
        
        # Process updates
        any_changed = False
        for name in routers:
            changed = router_objects[name].process_updates()
            if changed:
                any_changed = True
        
        if not any_changed:
            break
        
        # Print distance tables
        for name in routers:
            router_objects[name].print_distance_table(t)
    
    # Update and print routing tables
    for name in routers:
        router_objects[name].update_routing_table()
        router_objects[name].print_routing_table()

def main():
    # Read input
    routers, graph, updates = read_input()
    
    # Run initial distance vector algorithm
    router_objects = run_distance_vector(routers, graph)
    
    # Apply updates if any
    if updates:
        apply_updates(router_objects, graph, updates)

if __name__ == "__main__":
    main()
