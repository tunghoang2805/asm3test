#!/usr/bin/env python3

import sys
import copy
import math

class NetworkGraph:
    def __init__(self):
        self.connections = {}
    
    def add_connection(self, node_a, node_b, cost):
        if node_a not in self.connections:
            self.connections[node_a] = {}
        if node_b not in self.connections:
            self.connections[node_b] = {}
        
        self.connections[node_a][node_b] = cost
        self.connections[node_b][node_a] = cost
    
    def remove_connection(self, node_a, node_b):
        if node_a in self.connections and node_b in self.connections[node_a]:
            del self.connections[node_a][node_b]
        if node_b in self.connections and node_a in self.connections[node_b]:
            del self.connections[node_b][node_a]
    
    def get_adjacent_nodes(self, node):
        return self.connections.get(node, {})

class NetworkRouter:
    def __init__(self, router_id):
        self.router_id = router_id
        self.distance_vectors = {}
        self.pending_updates = []
        self.final_routes = {}
        self.needs_to_broadcast = False
    
    def setup_initial_distances(self, all_nodes):
        other_nodes = [n for n in all_nodes if n != self.router_id]
        
        for destination in other_nodes:
            self.distance_vectors[destination] = {}
            for via_node in other_nodes:
                self.distance_vectors[destination][via_node] = math.inf
    
    def display_distance_vectors(self):
        destinations = sorted(self.distance_vectors.keys())
        header_row = [' '] + destinations
        print('\t'.join(header_row))
        
        for dest in destinations:
            values = [str(self.distance_vectors[dest][via]).replace('inf', 'INF') for via in destinations]
            row = [dest] + values
            print('\t'.join(row))
    
    def refresh_direct_connections(self, network, all_routers):
        adjacent = network.get_adjacent_nodes(self.router_id)
        
        # Update direct neighbor costs
        for neighbor_id, link_cost in adjacent.items():
            self.distance_vectors[neighbor_id][neighbor_id] = link_cost
        
        # Set unreachable nodes to infinity
        for router in all_routers:
            if router.router_id not in adjacent and router.router_id != self.router_id:
                for dest in self.distance_vectors:
                    self.distance_vectors[dest][router.router_id] = math.inf
        
        self.needs_to_broadcast = True
    
    def broadcast_to_neighbors(self, adjacent_nodes, router_collection):
        if self.needs_to_broadcast:
            for router in router_collection:
                if router.router_id in adjacent_nodes:
                    router.pending_updates.append((self.router_id, copy.deepcopy(self.distance_vectors)))
            self.needs_to_broadcast = False
    
    def handle_incoming_updates(self):
        for sender_id, received_vectors in self.pending_updates:
            for destination in self.distance_vectors:
                if destination == sender_id:
                    continue
                
                previous_cost = self.distance_vectors[destination][sender_id]
                cost_to_sender = self.distance_vectors[sender_id][sender_id]
                best_cost_via_sender = self.calculate_minimum_distance(received_vectors, destination)[0]
                new_total_cost = cost_to_sender + best_cost_via_sender
                
                self.distance_vectors[destination][sender_id] = new_total_cost
                
                if previous_cost != new_total_cost:
                    self.needs_to_broadcast = True
        
        self.pending_updates.clear()
    
    def calculate_minimum_distance(self, vectors, target):
        min_distance = math.inf
        best_next_hop = None
        
        for via_node in vectors[target]:
            if vectors[target][via_node] < min_distance:
                min_distance = vectors[target][via_node]
                best_next_hop = via_node
        
        return (min_distance, best_next_hop)
    
    def build_routing_table(self):
        for destination in self.distance_vectors:
            min_cost, next_hop = self.calculate_minimum_distance(self.distance_vectors, destination)
            self.final_routes[destination] = (next_hop, min_cost)
    
    def display_routing_table(self):
        self.build_routing_table()
        print(f"Routing Table of router {self.router_id}:")
        for dest in sorted(self.final_routes.keys()):
            next_hop, cost = self.final_routes[dest]
            print(f"{dest},{next_hop},{cost}")
        print()
    
    def handle_topology_change(self, network, router_collection):
        original_vectors = copy.deepcopy(self.distance_vectors)
        self.pending_updates.clear()
        self.refresh_direct_connections(network, router_collection)
        
        # Update based on other routers' current routing tables
        neighbors = network.get_adjacent_nodes(self.router_id)
        for router in router_collection:
            if router.router_id in neighbors:
                for dest in router.final_routes:
                    if dest == self.router_id:
                        continue
                    
                    cost_to_neighbor = self.distance_vectors[router.router_id][router.router_id]
                    neighbor_to_dest_cost = router.final_routes[dest][1]
                    self.distance_vectors[dest][router.router_id] = cost_to_neighbor + neighbor_to_dest_cost
        
        if self.distance_vectors != original_vectors:
            self.needs_to_broadcast = True

# Main execution starts here
node_names = []
network = NetworkGraph()

# Parse node names
current_line = sys.stdin.readline().strip()
while current_line != "START":
    node_names.append(current_line)
    router_instance = NetworkRouter(current_line)
    network.connections[router_instance.router_id] = {}
    current_line = sys.stdin.readline().strip()

# Parse network edges
current_line = sys.stdin.readline().strip()
while current_line != "UPDATE":
    node_a, node_b, edge_weight = current_line.split()
    network.add_connection(node_a, node_b, int(edge_weight))
    current_line = sys.stdin.readline().strip()

# Initialize all routers
router_instances = []
for node_name in node_names:
    router = NetworkRouter(node_name)
    router.setup_initial_distances(node_names)
    router.refresh_direct_connections(network, router_instances)
    router_instances.append(router)

# Display initial state
for router in router_instances:
    print(f"Distance Table of router {router.router_id} at t=0:")
    router.display_distance_vectors()
    print()

# Run convergence algorithm
time_step = 1
previous_state = {}
for router in router_instances:
    previous_state[router.router_id] = copy.deepcopy(router.distance_vectors)

while True:
    # Send updates to neighbors
    for router in router_instances:
        router.broadcast_to_neighbors(network.get_adjacent_nodes(router.router_id), router_instances)
    
    # Process received updates
    for router in router_instances:
        router.handle_incoming_updates()
    
    # Check for convergence
    converged = all(router.distance_vectors == previous_state[router.router_id] for router in router_instances)
    if converged:
        break
    
    # Store current state
    previous_state = {}
    for router in router_instances:
        previous_state[router.router_id] = copy.deepcopy(router.distance_vectors)
    
    # Display current state
    for router in router_instances:
        print(f"Distance Table of router {router.router_id} at t={time_step}:")
        router.display_distance_vectors()
        print()
    
    time_step += 1
    
    # Additional convergence check
    if all(not router.needs_to_broadcast for router in router_instances):
        break

# Display final routing tables
for router in router_instances:
    router.display_routing_table()

# Handle dynamic updates
while True:
    update_line = sys.stdin.readline().strip()
    if update_line == "END":
        break
    
    node_a, node_b, new_weight = update_line.split()
    if int(new_weight) == -1:
        network.remove_connection(node_a, node_b)
    else:
        network.add_connection(node_a, node_b, int(new_weight))

# Store state before processing changes
previous_state = {}
for router in router_instances:
    previous_state[router.router_id] = copy.deepcopy(router.distance_vectors)

# Process topology changes
for router in router_instances:
    router.handle_topology_change(network, router_instances)

# Check if any changes occurred
no_changes = all(router.distance_vectors == previous_state[router.router_id] for router in router_instances)
if no_changes:
    sys.exit()

# Display state after topology change
for router in router_instances:
    print(f"Distance Table of router {router.router_id} at t={time_step}:")
    router.display_distance_vectors()
    print()

time_step += 1
previous_state = {}
for router in router_instances:
    previous_state[router.router_id] = copy.deepcopy(router.distance_vectors)

# Continue convergence after topology change
while True:
    # Exchange updates
    for router in router_instances:
        router.broadcast_to_neighbors(network.get_adjacent_nodes(router.router_id), router_instances)
    
    # Process updates
    for router in router_instances:
        router.handle_incoming_updates()
    
    # Check convergence
    converged = all(router.distance_vectors == previous_state[router.router_id] for router in router_instances)
    if converged:
        break
    
    # Update state tracking
    previous_state = {}
    for router in router_instances:
        previous_state[router.router_id] = copy.deepcopy(router.distance_vectors)
    
    # Display progress
    for router in router_instances:
        print(f"Distance Table of router {router.router_id} at t={time_step}:")
        router.display_distance_vectors()
        print()
    
    time_step += 1
    
    if all(not router.needs_to_broadcast for router in router_instances):
        break

# Display final routing tables after updates
for router in router_instances:
    router.display_routing_table()
