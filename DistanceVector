#!/usr/bin/env python3

import sys
import math

class Graph:
    # Represents a network graph with weighted edges between routers.
    def __init__(self):
        self.vertex_dict = {}
    
    def add_edge(self, v1, v2, weight):
        # Add a bidirectional weighted edge between two routers.
        if v1 not in self.vertex_dict:
            self.vertex_dict[v1] = {}
        if v2 not in self.vertex_dict:
            self.vertex_dict[v2] = {}
        self.vertex_dict[v1][v2] = weight
        self.vertex_dict[v2][v1] = weight
    
    def remove_edge(self, v1, v2):
        # Remove the edge between two routers.
        if v1 not in self.vertex_dict or v2 not in self.vertex_dict:
            return
        if v2 in self.vertex_dict[v1]:
            del self.vertex_dict[v1][v2]
        if v1 in self.vertex_dict[v2]:
            del self.vertex_dict[v2][v1]
    
    def get_neighbors(self, v):
        # Get all neighbors of a router.
        return self.vertex_dict.get(v, {})

class Router:
    def __init__(self, name):
        self.name = name
        self.distance_table = {}
        self.routing_table = {}
        self.needs_update = False
        
    def initialize_distance_table(self, all_nodes):
        # Initialize distance table with all destinations and next hops
        nodes = [n for n in all_nodes if n != self.name]
        
        for dest in nodes:
            self.distance_table[dest] = {}
            for next_hop in nodes:
                self.distance_table[dest][next_hop] = math.inf
    
    def update_direct_costs(self, graph):
        # Update distance table with direct costs to neighbors
        neighbors = graph.get_neighbors(self.name)
        
        for neighbor in neighbors:
            if neighbor in self.distance_table:
                old_cost = self.distance_table[neighbor][neighbor]
                new_cost = neighbors[neighbor]
                self.distance_table[neighbor][neighbor] = new_cost
                if old_cost != new_cost:
                    self.needs_update = True
    
    def get_distance_vector(self):
        # Return current distance vector (min cost to each destination)
        dv = {}
        for dest in self.distance_table:
            min_cost = min(self.distance_table[dest].values())
            dv[dest] = min_cost
        return dv
    
    def process_neighbor_update(self, neighbor_name, neighbor_dv, graph):
        # Process received distance vector from neighbor
        if neighbor_name not in self.distance_table:
            return
            
        # Get cost to this neighbor
        neighbors = graph.get_neighbors(self.name)
        cost_to_neighbor = neighbors.get(neighbor_name, math.inf)
        
        # Update distance table entries via this neighbor
        for dest in self.distance_table:
            if dest == neighbor_name:
                continue
                
            old_cost = self.distance_table[dest][neighbor_name]
            neighbor_cost_to_dest = neighbor_dv.get(dest, math.inf)
            
            if cost_to_neighbor == math.inf or neighbor_cost_to_dest == math.inf:
                new_cost = math.inf
            else:
                new_cost = cost_to_neighbor + neighbor_cost_to_dest
            
            self.distance_table[dest][neighbor_name] = new_cost
            
            if old_cost != new_cost:
                self.needs_update = True
    
    def create_routing_table(self):
        # Create routing table from distance table
        self.routing_table = {}
        
        for dest in sorted(self.distance_table.keys()):
            min_cost = math.inf
            best_next_hop = None
            
            # Find minimum cost path (alphabetically first if tie)
            for next_hop in sorted(self.distance_table[dest].keys()):
                cost = self.distance_table[dest][next_hop]
                if cost < min_cost:
                    min_cost = cost
                    best_next_hop = next_hop
            
            self.routing_table[dest] = (best_next_hop, min_cost)
    
    def print_distance_table(self, time_step):
        # Print distance table in required format
        print(f"Distance Table of router {self.name} at t={time_step}:")
        
        destinations = sorted(self.distance_table.keys())
        if not destinations:
            print()
            return
            
        # Print header
        header = [' '] + destinations
        print('\t'.join(header))
        
        # Print rows
        for next_hop in destinations:
            row = [next_hop]
            for dest in destinations:
                cost = self.distance_table[dest][next_hop]
                if cost == math.inf:
                    row.append('INF')
                else:
                    row.append(str(int(cost)))
            print('\t'.join(row))
        print()
    
    def print_routing_table(self):
        # Print routing table in required format
        self.create_routing_table()
        print(f"Routing Table of router {self.name}:")
        
        for dest in sorted(self.routing_table.keys()):
            next_hop, cost = self.routing_table[dest]
            if cost == math.inf:
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{next_hop},{int(cost)}")
        print()

def run_distance_vector_algorithm(graph, router_names):
    # Create router objects
    routers = {}
    for name in router_names:
        routers[name] = Router(name)
        routers[name].initialize_distance_table(router_names)
        routers[name].update_direct_costs(graph)
        routers[name].needs_update = True
    
    time_step = 0
    
    # Print initial distance tables
    for name in sorted(router_names):
        routers[name].print_distance_table(time_step)
    
    # Run algorithm until convergence
    while True:
        time_step += 1
        
        # Get all current distance vectors
        distance_vectors = {}
        for name in router_names:
            distance_vectors[name] = routers[name].get_distance_vector()
        
        # Process updates from neighbors
        any_updates = False
        for name in router_names:
            router = routers[name]
            neighbors = graph.get_neighbors(name)
            
            for neighbor_name in neighbors:
                if neighbor_name in distance_vectors:
                    router.process_neighbor_update(neighbor_name, distance_vectors[neighbor_name], graph)
            
            if router.needs_update:
                any_updates = True
        
        # Check for convergence
        if not any_updates:
            break
        
        # Print distance tables if there were updates
        for name in sorted(router_names):
            if routers[name].needs_update:
                routers[name].print_distance_table(time_step)
                routers[name].needs_update = False
    
    # Print final routing tables
    for name in sorted(router_names):
        routers[name].print_routing_table()
    
    return time_step

def main():
    graph = Graph()
    router_names = []
    
    # Read router names
    while True:
        line = sys.stdin.readline().strip()
        if line == "START":
            break
        router_names.append(line)
        graph.vertex_dict[line] = {}
    
    # Read initial topology
    while True:
        line = sys.stdin.readline().strip()
        if line == "UPDATE":
            break
        
        parts = line.split()
        if len(parts) == 3:
            node1, node2, weight = parts[0], parts[1], int(parts[2])
            if weight == -1:
                graph.remove_edge(node1, node2)
            else:
                graph.add_edge(node1, node2, weight)
    
    # Run initial algorithm
    current_time = run_distance_vector_algorithm(graph, router_names)
    
    # Process topology updates
    while True:
        try:
            line = sys.stdin.readline().strip()
            if line == "END":
                break
            
            parts = line.split()
            if len(parts) == 3:
                node1, node2, weight = parts[0], parts[1], int(parts[2])
                if weight == -1:
                    graph.remove_edge(node1, node2)
                else:
                    graph.add_edge(node1, node2, weight)
                
                # Run algorithm again after update
                current_time = run_distance_vector_algorithm(graph, router_names)
        
        except EOFError:
            break

if __name__ == "__main__":
    main()
