#!/usr/bin/env python3

import sys
import math
import copy

INF = math.inf

class Graph:
    def __init__(self):
        self.vertex_dict = {}

    def add_edge(self, v1, v2, weight):
        if weight == -1:
            self.remove_edge(v1, v2)
            return
        if v1 not in self.vertex_dict:
            self.vertex_dict[v1] = {}
        if v2 not in self.vertex_dict:
            self.vertex_dict[v2] = {}
        self.vertex_dict[v1][v2] = weight
        self.vertex_dict[v2][v1] = weight

    def remove_edge(self, v1, v2):
        if v1 in self.vertex_dict and v2 in self.vertex_dict[v1]:
            del self.vertex_dict[v1][v2]
        if v2 in self.vertex_dict and v1 in self.vertex_dict[v2]:
            del self.vertex_dict[v2][v1]

    def get_neighbors(self, v):
        return self.vertex_dict.get(v, {})

    def get_nodes(self):
        return sorted(self.vertex_dict.keys())

class Router:
    def __init__(self, name, graph):
        self.name = name
        self.graph = graph
        self.distance_table = {}
        self.pending_updates = []
        self.routing_table = {}
        self.changed = True

    def initialize(self, all_nodes):
        # Set up distance table with INF, except for direct neighbors
        nodes = [n for n in all_nodes if n != self.name]
        for dest in nodes:
            self.distance_table[dest] = {}
            for via in nodes:
                self.distance_table[dest][via] = INF
        # Direct neighbors
        for neighbor, cost in self.graph.get_neighbors(self.name).items():
            if neighbor != self.name:
                self.distance_table[neighbor][neighbor] = cost

    def update_from_graph(self, all_nodes):
        # Refresh direct neighbors in distance table
        neighbors = self.graph.get_neighbors(self.name)
        for dest in all_nodes:
            if dest == self.name:
                continue
            if dest in neighbors:
                self.distance_table.setdefault(dest, {})
                self.distance_table[dest][dest] = neighbors[dest]
            else:
                self.distance_table.setdefault(dest, {})
                self.distance_table[dest][dest] = INF

    def send_updates(self, routers):
        if self.changed:
            for router in routers:
                if router.name in self.graph.get_neighbors(self.name):
                    router.pending_updates.append((self.name, copy.deepcopy(self.distance_table)))
            self.changed = False

    def receive_updates(self):
        for sender, sender_table in self.pending_updates:
            for dest in self.distance_table:
                if dest == sender:
                    continue
                cost_to_sender = self.distance_table[sender][sender]
                min_cost, _ = self._find_min(sender_table, dest)
                potential = cost_to_sender + min_cost
                prev = self.distance_table[dest].get(sender, INF)
                if potential < prev:
                    self.distance_table[dest][sender] = potential
                    self.changed = True
        self.pending_updates = []

    def _find_min(self, table, dest):
        min_cost = INF
        next_hop = None
        for via, cost in table[dest].items():
            if cost < min_cost:
                min_cost = cost
                next_hop = via
        return min_cost, next_hop

    def update_routing_table(self):
        for dest in self.distance_table:
            min_cost, next_hop = self._find_min(self.distance_table, dest)
            self.routing_table[dest] = (next_hop, min_cost)

    def print_distance_table(self, t):
        nodes = sorted(self.distance_table.keys())
        print(f"Distance Table of router {self.name} at t={t}:")
        header = "    " + "   ".join(nodes)
        print(header)
        for dest in nodes:
            row = [dest]
            for via in nodes:
                val = self.distance_table[dest].get(via, INF)
                row.append(str(int(val)) if val != INF else "INF")
            print("  ".join(row))
        print()

    def print_routing_table(self):
        self.update_routing_table()
        print(f"Routing Table of router {self.name}:")
        for dest in sorted(self.routing_table.keys()):
            next_hop, cost = self.routing_table[dest]
            if cost == INF or next_hop is None:
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{next_hop},{int(cost)}")
        print()

def read_input():
    graph = Graph()
    routers = []
    # Read router names
    while True:
        line = sys.stdin.readline().strip()
        if line == "START":
            break
        if line:
            routers.append(line)
            graph.vertex_dict[line] = {}
    # Read initial edges
    while True:
        line = sys.stdin.readline().strip()
        if line == "UPDATE":
            break
        if line:
            v1, v2, w = line.split()
            graph.add_edge(v1, v2, int(w))
    # Read updates
    updates = []
    while True:
        line = sys.stdin.readline().strip()
        if line == "END":
            break
        if line:
            v1, v2, w = line.split()
            updates.append((v1, v2, int(w)))
    return graph, routers, updates

def run_distance_vector(graph, routers, updates):
    router_objs = {name: Router(name, graph) for name in routers}
    for router in router_objs.values():
        router.initialize(routers)
        router.update_from_graph(routers)

    # Initial print
    t = 0
    for router in routers:
        router_objs[router].print_distance_table(t)

    # Main DV loop
    t = 1
    while True:
        for router in routers:
            router_objs[router].send_updates([router_objs[n] for n in routers])
        for router in routers:
            router_objs[router].receive_updates()
        # Print distance tables
        for router in routers:
            router_objs[router].print_distance_table(t)
        # Check for convergence
        if not any(router_objs[r].changed for r in routers):
            break
        t += 1

    # Print routing tables
    for router in routers:
        router_objs[router].print_routing_table()

    # Apply updates
    for v1, v2, w in updates:
        graph.add_edge(v1, v2, w)
    if updates:
        # After update, refresh routers and rerun DV
        for router in router_objs.values():
            router.update_from_graph(routers)
            router.changed = True
        t += 1
        while True:
            for router in routers:
                router_objs[router].send_updates([router_objs[n] for n in routers])
            for router in routers:
                router_objs[router].receive_updates()
            for router in routers:
                router_objs[router].print_distance_table(t)
            if not any(router_objs[r].changed for r in routers):
                break
            t += 1
        for router in routers:
            router_objs[router].print_routing_table()

def main():
    graph, routers, updates = read_input()
    run_distance_vector(graph, routers, updates)

if __name__ == "__main__":
    main()
