import sys
import math
from collections import defaultdict, deque

INF = float('inf')

def parse_input():
    routers = []
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "START":
            break
        routers.append(line)

    edges = []
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "UPDATE":
            break
        n1, n2, w = line.split()
        edges.append((n1, n2, int(w)))

    updates = []
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "END":
            break
        n1, n2, w = line.split()
        updates.append((n1, n2, int(w)))

    return routers, edges, updates

class Node:
    def __init__(self, name, all_routers):
        self.name = name
        self.neighbors = {}  # neighbor: cost
        self.all_routers = set(all_routers)
        self.distance_table = {}  # dest: { via: cost }
        self.dv = {}  # dest: (cost, next_hop)
        self.reset_tables()

    def reset_tables(self):
        for dest in self.all_routers:
            if dest == self.name:
                continue
            self.distance_table[dest] = {}
            for via in self.all_routers:
                if via == self.name:
                    continue
                self.distance_table[dest][via] = INF
        self.update_dv()

    def update_dv(self):
        for dest in self.distance_table:
            min_cost = INF
            min_via = None
            for via in self.distance_table[dest]:
                if self.distance_table[dest][via] < min_cost:
                    min_cost = self.distance_table[dest][via]
                    min_via = via
            self.dv[dest] = (min_cost, min_via)

    def set_neighbor(self, neighbor, cost):
        self.neighbors[neighbor] = cost

    def remove_neighbor(self, neighbor):
        if neighbor in self.neighbors:
            del self.neighbors[neighbor]

    def initialize(self):
        # Direct links
        for dest in self.distance_table:
            if dest in self.neighbors:
                self.distance_table[dest][dest] = self.neighbors[dest]
            else:
                self.distance_table[dest][dest] = INF
        self.update_dv()

    def send_vector(self):
        # Send own vector to all neighbors
        return dict(self.dv)

    def receive_vector(self, from_neighbor, vector, cost_to_neighbor):
        changed = False
        for dest in self.distance_table:
            if dest == from_neighbor:
                continue
            # cost to dest via from_neighbor
            via_cost = cost_to_neighbor + (vector[dest][0] if vector[dest][0] != INF else INF)
            if self.distance_table[dest][from_neighbor] != via_cost:
                self.distance_table[dest][from_neighbor] = via_cost
                changed = True
        return changed

    def print_distance_table(self, t):
        routers = sorted(self.all_routers - {self.name})
        print(f"Distance Table of router {self.name} at t={t}:")
        header = "  " + "  ".join(routers)
        print(header)
        for via in routers:
            row = [via]
            for dest in routers:
                val = self.distance_table[dest][via]
                row.append("INF" if val == INF else str(int(val)))
            print(" ".join(row))
        print()

    def print_routing_table(self):
        print(f"Routing Table of router {self.name}:")
        for dest in sorted(self.all_routers - {self.name}):
            cost, nh = self.dv[dest]
            if cost == INF or nh is None:
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{nh},{int(cost)}")
        print()

def run_distance_vector(nodes_dict):
    t = 0
    # Initial distance tables
    for node in sorted(nodes_dict.values(), key=lambda x: x.name):
        node.print_distance_table(t)
    # Distance vector algorithm
    converged = False
    t = 1
    while not converged:
        changed_any = False
        # Each node sends its vector to neighbors
        vectors = {}
        for name, node in nodes_dict.items():
            vectors[name] = node.send_vector()
        # Each node receives from neighbors
        for name, node in nodes_dict.items():
            for neighbor in node.neighbors:
                changed = node.receive_vector(
                    neighbor,
                    vectors[neighbor],
                    node.neighbors[neighbor]
                )
                if changed:
                    node.update_dv()
                    changed_any = True
        if changed_any:
            for node in sorted(nodes_dict.values(), key=lambda x: x.name):
                node.print_distance_table(t)
            t += 1
        else:
            converged = True

def print_all_routing_tables(nodes_dict):
    for node in sorted(nodes_dict.values(), key=lambda x: x.name):
        node.print_routing_table()

def build_network(routers, edges):
    all_routers = set(routers)
    nodes_dict = {name: Node(name, all_routers) for name in routers}
    # Set neighbors
    for n1, n2, w in edges:
        if n1 not in nodes_dict:
            all_routers.add(n1)
            nodes_dict[n1] = Node(n1, all_routers)
        if n2 not in nodes_dict:
            all_routers.add(n2)
            nodes_dict[n2] = Node(n2, all_routers)
        nodes_dict[n1].set_neighbor(n2, w)
        nodes_dict[n2].set_neighbor(n1, w)
    # Reset all tables with possible new routers
    for node in nodes_dict.values():
        node.all_routers = set(nodes_dict.keys())
        node.reset_tables()
    # Initialize direct links
    for node in nodes_dict.values():
        node.initialize()
    return nodes_dict

def apply_updates(nodes_dict, updates):
    # Add/remove edges
    for n1, n2, w in updates:
        if n1 not in nodes_dict:
            nodes_dict[n1] = Node(n1, set(nodes_dict.keys()) | {n1})
        if n2 not in nodes_dict:
            nodes_dict[n2] = Node(n2, set(nodes_dict.keys()) | {n2})
        for node in nodes_dict.values():
            node.all_routers = set(nodes_dict.keys())
            node.reset_tables()
        if w == -1:
            nodes_dict[n1].remove_neighbor(n2)
            nodes_dict[n2].remove_neighbor(n1)
        else:
            nodes_dict[n1].set_neighbor(n2, w)
            nodes_dict[n2].set_neighbor(n1, w)
    # Re-initialize direct links
    for node in nodes_dict.values():
        node.initialize()

def main():
    routers, edges, updates = parse_input()
    nodes_dict = build_network(routers, edges)
    run_distance_vector(nodes_dict)
    print_all_routing_tables(nodes_dict)
    if updates:
        apply_updates(nodes_dict, updates)
        run_distance_vector(nodes_dict)
        print_all_routing_tables(nodes_dict)

if __name__ == "__main__":
    main()
