#!/usr/bin/env python3

import sys
import copy
import math

class NetworkTopology:
    """Manages the network topology and adjacency relationships"""
    
    def __init__(self):
        self.adjacency = {}
    
    def add_router(self, router_name):
        """Add a router to the topology"""
        if router_name not in self.adjacency:
            self.adjacency[router_name] = {}
    
    def add_link(self, router1, router2, cost):
        """Add or update a bidirectional link between two routers"""
        self.add_router(router1)
        self.add_router(router2)
        self.adjacency[router1][router2] = cost
        self.adjacency[router2][router1] = cost
    
    def remove_link(self, router1, router2):
        """Remove a bidirectional link between two routers"""
        if router1 in self.adjacency and router2 in self.adjacency[router1]:
            del self.adjacency[router1][router2]
        if router2 in self.adjacency and router1 in self.adjacency[router2]:
            del self.adjacency[router2][router1]
    
    def get_neighbors(self, router_name):
        """Get all neighbors of a given router"""
        return self.adjacency.get(router_name, {})
    
    def get_all_routers(self):
        """Get all router names in the topology"""
        return list(self.adjacency.keys())

class DistanceVectorRouter:
    """Implements a single router using Distance Vector algorithm"""
    
    def __init__(self, name):
        self.name = name
        self.distance_table = {}  # distance_table[dest][via] = cost
        self.routing_table = {}   # routing_table[dest] = (next_hop, cost)
        self.needs_update = False
        self.pending_updates = []  # List of (sender, distance_vector) tuples
    
    def initialize(self, all_routers, topology):
        """Initialize distance table with all destinations and via nodes"""
        other_routers = [r for r in all_routers if r != self.name]
        
        # Initialize distance table with infinity
        for dest in other_routers:
            self.distance_table[dest] = {}
            for via in other_routers:
                self.distance_table[dest][via] = math.inf
        
        # Set direct neighbor costs
        neighbors = topology.get_neighbors(self.name)
        for neighbor, cost in neighbors.items():
            if neighbor in self.distance_table:
                self.distance_table[neighbor][neighbor] = cost
        
        self.needs_update = True
    
    def get_distance_vector(self):
        """Get current distance vector (minimum costs to all destinations)"""
        distance_vector = {}
        for dest in self.distance_table:
            min_cost = min(self.distance_table[dest].values())
            distance_vector[dest] = min_cost
        return distance_vector
    
    def send_updates(self, all_routers, topology):
        """Send distance vector to all neighbors if update is needed"""
        if not self.needs_update:
            return
        
        neighbors = topology.get_neighbors(self.name)
        distance_vector = self.get_distance_vector()
        
        # Send to each neighbor router
        for router in all_routers:
            if router.name in neighbors:
                router.receive_update(self.name, distance_vector)
        
        self.needs_update = False
    
    def receive_update(self, sender, distance_vector):
        """Receive distance vector update from a neighbor"""
        self.pending_updates.append((sender, distance_vector))
    
    def process_updates(self, topology):
        """Process all pending updates using Bellman-Ford equation"""
        if not self.pending_updates:
            return
        
        table_changed = False
        neighbors = topology.get_neighbors(self.name)
        
        for sender, received_vector in self.pending_updates:
            if sender not in neighbors:
                continue
            
            # Update distance table based on received information
            cost_to_sender = neighbors[sender]
            
            for dest in received_vector:
                if dest == self.name:
                    continue
                
                if dest in self.distance_table:
                    # Calculate new cost via this sender
                    new_cost = cost_to_sender + received_vector[dest]
                    old_cost = self.distance_table[dest].get(sender, math.inf)
                    
                    if new_cost != old_cost:
                        self.distance_table[dest][sender] = new_cost
                        table_changed = True
        
        if table_changed:
            self.needs_update = True
        
        self.pending_updates.clear()
    
    def update_routing_table(self):
        """Update routing table based on current distance table"""
        self.routing_table.clear()
        
        for dest in sorted(self.distance_table.keys()):
            min_cost = math.inf
            best_next_hop = None
            
            # Find minimum cost path (with alphabetical tie-breaking)
            for via in sorted(self.distance_table[dest].keys()):
                cost = self.distance_table[dest][via]
                if cost < min_cost:
                    min_cost = cost
                    best_next_hop = via
            
            if best_next_hop is not None and min_cost != math.inf:
                self.routing_table[dest] = (best_next_hop, min_cost)
            else:
                self.routing_table[dest] = ("INF", "INF")
    
    def print_distance_table(self, step):
        """Print distance table in required format"""
        print(f"Distance Table of router {self.name} at t={step}:")
        
        if not self.distance_table:
            print()
            return
        
        destinations = sorted(self.distance_table.keys())
        
        # Print header
        header = "\t" + "\t".join(destinations)
        print(header)
        
        # Print each row
        for via in destinations:
            row_values = []
            for dest in destinations:
                cost = self.distance_table[dest].get(via, math.inf)
                cost_str = "INF" if cost == math.inf else str(int(cost))
                row_values.append(cost_str)
            
            print(f"{via}\t" + "\t".join(row_values))
        
        print()
    
    def print_routing_table(self):
        """Print routing table in required format"""
        print(f"Routing Table of router {self.name}:")
        
        for dest in sorted(self.routing_table.keys()):
            next_hop, cost = self.routing_table[dest]
            cost_str = cost if cost == "INF" else str(int(cost))
            print(f"{dest},{next_hop},{cost_str}")
        
        print()

def run_distance_vector_algorithm():
    """Main function to run the Distance Vector algorithm"""
    topology = NetworkTopology()
    router_names = []
    
    # Read router names
    while True:
        line = sys.stdin.readline().strip()
        if line == "START":
            break
        router_names.append(line)
        topology.add_router(line)
    
    # Read initial topology
    while True:
        line = sys.stdin.readline().strip()
        if line == "UPDATE":
            break
        
        parts = line.split()
        router1, router2, weight = parts[0], parts[1], int(parts[2])
        
        if weight == -1:
            topology.remove_link(router1, router2)
        else:
            topology.add_link(router1, router2, weight)
    
    # Create router instances
    routers = []
    for name in sorted(router_names):
        router = DistanceVectorRouter(name)
        routers.append(router)
    
    # Initialize all routers
    all_router_names = topology.get_all_routers()
    for router in routers:
        router.initialize(all_router_names, topology)
    
    # Run algorithm until convergence
    step = 0
    
    # Print initial state
    for router in routers:
        router.print_distance_table(step)
    
    while True:
        step += 1
        
        # Send updates from all routers
        for router in routers:
            router.send_updates(routers, topology)
        
        # Process received updates
        any_changes = False
        for router in routers:
            old_table = copy.deepcopy(router.distance_table)
            router.process_updates(topology)
            if router.distance_table != old_table:
                any_changes = True
        
        # Check for convergence
        if not any_changes and not any(r.needs_update for r in routers):
            break
        
        # Print distance tables
        for router in routers:
            router.print_distance_table(step)
    
    # Print final routing tables
    for router in routers:
        router.update_routing_table()
        router.print_routing_table()
    
    # Handle topology updates
    while True:
        line = sys.stdin.readline().strip()
        if line == "END":
            break
        
        parts = line.split()
        router1, router2, weight = parts[0], parts[1], int(parts[2])
        
        # Add new routers if they don't exist
        if router1 not in all_router_names:
            topology.add_router(router1)
            new_router = DistanceVectorRouter(router1)
            routers.append(new_router)
            all_router_names.append(router1)
        
        if router2 not in all_router_names:
            topology.add_router(router2)
            new_router = DistanceVectorRouter(router2)
            routers.append(new_router)
            all_router_names.append(router2)
        
        # Update topology
        if weight == -1:
            topology.remove_link(router1, router2)
        else:
            topology.add_link(router1, router2, weight)
        
        # Re-initialize routers with new topology
        routers.sort(key=lambda x: x.name)  # Maintain alphabetical order
        for router in routers:
            router.initialize(topology.get_all_routers(), topology)
        
        # Run algorithm again until convergence
        step = 0
        
        while True:
            step += 1
            
            # Send updates
            for router in routers:
                router.send_updates(routers, topology)
            
            # Process updates
            any_changes = False
            for router in routers:
                old_table = copy.deepcopy(router.distance_table)
                router.process_updates(topology)
                if router.distance_table != old_table:
                    any_changes = True
            
            # Check convergence
            if not any_changes and not any(r.needs_update for r in routers):
                break
            
            # Print distance tables
            for router in routers:
                router.print_distance_table(step)
        
        # Print final routing tables
        for router in routers:
            router.update_routing_table()
            router.print_routing_table()
        
        break  # Exit after processing updates

if __name__ == "__main__":
    run_distance_vector_algorithm()
