#!/usr/bin/env python3

import sys
import copy
import math

def read_input():
    """Read and parse the input to get nodes, edges, and updates"""
    nodes = []
    edges = []
    updates = []
    
    # Read nodes
    line = sys.stdin.readline().strip()
    while line != "START":
        nodes.append(line)
        line = sys.stdin.readline().strip()
    
    # Read edges
    line = sys.stdin.readline().strip()
    while line != "UPDATE":
        parts = line.split()
        edges.append((parts[0], parts[1], int(parts[2])))
        line = sys.stdin.readline().strip()
    
    # Read updates
    while True:
        line = sys.stdin.readline().strip()
        if line == "END":
            break
        parts = line.split()
        updates.append((parts[0], parts[1], int(parts[2])))
    
    return nodes, edges, updates

def build_adjacency_matrix(nodes, edges):
    """Build adjacency matrix from edges"""
    n = len(nodes)
    node_to_idx = {node: i for i, node in enumerate(nodes)}
    adj_matrix = [[math.inf] * n for _ in range(n)]
    
    # Set diagonal to 0
    for i in range(n):
        adj_matrix[i][i] = 0
    
    # Add edges
    for node1, node2, weight in edges:
        i, j = node_to_idx[node1], node_to_idx[node2]
        adj_matrix[i][j] = weight
        adj_matrix[j][i] = weight
    
    return adj_matrix, node_to_idx

def initialize_distance_vectors(nodes, adj_matrix):
    """Initialize distance vectors for each node"""
    n = len(nodes)
    distance_vectors = {}
    
    for i, node in enumerate(nodes):
        distance_vectors[node] = {}
        for j, dest in enumerate(nodes):
            if i == j:
                continue
            distance_vectors[node][dest] = {}
            for k, via in enumerate(nodes):
                if k == i:
                    continue
                if adj_matrix[i][k] != math.inf:
                    distance_vectors[node][dest][via] = adj_matrix[i][k]
                else:
                    distance_vectors[node][dest][via] = math.inf
    
    return distance_vectors

def get_neighbors(node, nodes, adj_matrix, node_to_idx):
    """Get neighbors of a node"""
    neighbors = []
    node_idx = node_to_idx[node]
    for i, other_node in enumerate(nodes):
        if i != node_idx and adj_matrix[node_idx][i] != math.inf:
            neighbors.append(other_node)
    return neighbors

def format_distance_table(node, distance_vectors, nodes):
    """Format and print distance table for a node"""
    destinations = [n for n in nodes if n != node]
    destinations.sort()
    
    if not destinations:
        return
    
    # Print header
    header = [' '] + destinations
    print('\t'.join(header))
    
    # Print rows
    for dest in destinations:
        row_values = [dest]
        for via in destinations:
            value = distance_vectors[node][dest][via]
            if value == math.inf:
                row_values.append('INF')
            else:
                row_values.append(str(int(value)))
        print('\t'.join(row_values))

def bellman_ford_step(distance_vectors, nodes, adj_matrix, node_to_idx):
    """Perform one step of the Bellman-Ford algorithm"""
    new_distance_vectors = copy.deepcopy(distance_vectors)
    changed = False
    
    for node in nodes:
        neighbors = get_neighbors(node, nodes, adj_matrix, node_to_idx)
        
        for dest in nodes:
            if dest == node:
                continue
                
            for neighbor in neighbors:
                if neighbor == dest:
                    continue
                
                # Get cost to neighbor
                cost_to_neighbor = adj_matrix[node_to_idx[node]][node_to_idx[neighbor]]
                
                # Find minimum cost from neighbor to destination
                min_cost_from_neighbor = math.inf
                for via in distance_vectors[neighbor][dest]:
                    if distance_vectors[neighbor][dest][via] < min_cost_from_neighbor:
                        min_cost_from_neighbor = distance_vectors[neighbor][dest][via]
                
                # Update distance vector
                new_cost = cost_to_neighbor + min_cost_from_neighbor
                if new_cost < new_distance_vectors[node][dest][neighbor]:
                    new_distance_vectors[node][dest][neighbor] = new_cost
                    changed = True
    
    return new_distance_vectors, changed

def create_routing_tables(distance_vectors, nodes):
    """Create routing tables from distance vectors"""
    routing_tables = {}
    
    for node in nodes:
        routing_tables[node] = {}
        for dest in nodes:
            if dest == node:
                continue
            
            min_cost = math.inf
            next_hop = None
            
            for via in distance_vectors[node][dest]:
                if distance_vectors[node][dest][via] < min_cost:
                    min_cost = distance_vectors[node][dest][via]
                    next_hop = via
            
            routing_tables[node][dest] = (next_hop, min_cost)
    
    return routing_tables

def print_routing_tables(routing_tables, nodes):
    """Print routing tables"""
    for node in nodes:
        print(f"Routing Table of router {node}:")
        destinations = [dest for dest in nodes if dest != node]
        destinations.sort()
        
        for dest in destinations:
            next_hop, cost = routing_tables[node][dest]
            if cost == math.inf:
                cost_str = "INF"
            else:
                cost_str = str(int(cost))
            print(f"{dest},{next_hop},{cost_str}")
        print()

def update_adjacency_matrix(adj_matrix, node_to_idx, updates):
    """Update adjacency matrix with new edges/removals"""
    for node1, node2, weight in updates:
        i, j = node_to_idx[node1], node_to_idx[node2]
        if weight == -1:
            adj_matrix[i][j] = math.inf
            adj_matrix[j][i] = math.inf
        else:
            adj_matrix[i][j] = weight
            adj_matrix[j][i] = weight

def main():
    nodes, edges, updates = read_input()
    adj_matrix, node_to_idx = build_adjacency_matrix(nodes, edges)
    distance_vectors = initialize_distance_vectors(nodes, adj_matrix)
    
    # Print initial distance tables
    for node in nodes:
        print(f"Distance Table of router {node} at t=0:")
        format_distance_table(node, distance_vectors, nodes)
        print()
    
    # Run algorithm until convergence
    t = 1
    while True:
        new_distance_vectors, changed = bellman_ford_step(distance_vectors, nodes, adj_matrix, node_to_idx)
        
        if not changed:
            break
        
        distance_vectors = new_distance_vectors
        
        # Print distance tables
        for node in nodes:
            print(f"Distance Table of router {node} at t={t}:")
            format_distance_table(node, distance_vectors, nodes)
            print()
        
        t += 1
    
    # Print routing tables
    routing_tables = create_routing_tables(distance_vectors, nodes)
    print_routing_tables(routing_tables, nodes)
    
    # Process updates
    if updates:
        update_adjacency_matrix(adj_matrix, node_to_idx, updates)
        
        # Reinitialize distance vectors with new topology
        old_distance_vectors = copy.deepcopy(distance_vectors)
        distance_vectors = initialize_distance_vectors(nodes, adj_matrix)
        
        # Check if anything changed
        if distance_vectors == old_distance_vectors:
            return
        
        # Print updated distance tables
        for node in nodes:
            print(f"Distance Table of router {node} at t={t}:")
            format_distance_table(node, distance_vectors, nodes)
            print()
        
        t += 1
        
        # Run algorithm until convergence again
        while True:
            new_distance_vectors, changed = bellman_ford_step(distance_vectors, nodes, adj_matrix, node_to_idx)
            
            if not changed:
                break
            
            distance_vectors = new_distance_vectors
            
            # Print distance tables
            for node in nodes:
                print(f"Distance Table of router {node} at t={t}:")
                format_distance_table(node, distance_vectors, nodes)
                print()
            
            t += 1
        
        # Print final routing tables
        routing_tables = create_routing_tables(distance_vectors, nodes)
        print_routing_tables(routing_tables, nodes)

if __name__ == "__main__":
    main()
