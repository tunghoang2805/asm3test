#!/usr/bin/env python3
import sys
from collections import defaultdict

INF = float('inf')

class Router:
    def __init__(self, name):
        self.name = name
        self.distance_vector = defaultdict(lambda: defaultdict(lambda: INF))
        self.neighbors = {}
        self.routing_table = {}

    def initialize(self, routers):
        """Initialize distance vector with direct neighbors"""
        for dest in routers:
            if dest == self.name:
                continue
            self.distance_vector[dest][dest] = self.neighbors.get(dest, INF)
        
        # Set self distance to 0
        self.distance_vector[self.name] = defaultdict(lambda: INF)
        self.distance_vector[self.name][self.name] = 0

    def update_distance_vector(self, neighbor, neighbor_dv):
        """Update distance vector based on neighbor's advertisement"""
        updated = False
        for dest in neighbor_dv:
            current_cost = self.distance_vector[dest].get(neighbor, INF)
            new_cost = self.neighbors[neighbor] + neighbor_dv[dest]
            
            if new_cost < current_cost:
                self.distance_vector[dest][neighbor] = new_cost
                updated = True
        return updated

    def compute_routing_table(self):
        """Compute best paths and update routing table"""
        updated = False
        for dest in self.distance_vector:
            if dest == self.name:
                continue
            
            # Find minimum cost and next hop
            min_cost = INF
            next_hop = None
            for neighbor in self.distance_vector[dest]:
                if self.distance_vector[dest][neighbor] < min_cost:
                    min_cost = self.distance_vector[dest][neighbor]
                    next_hop = neighbor
            
            # Update routing table if changed
            current_entry = self.routing_table.get(dest, (None, INF))
            if (next_hop, min_cost) != current_entry:
                self.routing_table[dest] = (next_hop, min_cost)
                updated = True
        
        return updated

def main():
    # Parse input
    routers = []
    links = []
    updates = []
    
    # Read router names
    while True:
        line = sys.stdin.readline().strip()
        if line == 'START':
            break
        routers.append(line)
    
    # Read initial links
    while True:
        line = sys.stdin.readline().strip()
        if line == 'UPDATE':
            break
        if line:
            parts = line.split()
            links.append((parts[0], parts[1], int(parts[2])))
    
    # Read updates
    while True:
        line = sys.stdin.readline().strip()
        if line == 'END':
            break
        if line:
            parts = line.split()
            updates.append((parts[0], parts[1], int(parts[2])))
    
    # Create network
    network = {name: Router(name) for name in routers}
    
    # Process initial links
    for a, b, cost in links:
        if cost == -1:
            continue
        network[a].neighbors[b] = cost
        network[b].neighbors[a] = cost
    
    # Initialize routers
    for router in network.values():
        router.initialize(routers)
    
    # Simulate DV algorithm
    time_step = 0
    while True:
        # Print distance tables
        for name in sorted(network):
            router = network[name]
            print(f"Distance Table of router {name} at t={time_step}:")
            # Print header
            others = sorted([r for r in routers if r != name])
            print("    " + "   ".join(others))
            # Print rows
            for dest in sorted(router.distance_vector):
                if dest == name:
                    continue
                costs = [str(router.distance_vector[dest].get(n, INF)).replace('inf', 'INF') 
                        for n in others]
                print(f"{dest}  " + "  ".join(costs))
            print()
        
        # Check convergence
        converged = True
        
        # Exchange distance vectors
        all_updates = {}
        for name in network:
            router = network[name]
            all_updates[name] = {dest: min(router.distance_vector[dest].values()) 
                               for dest in router.distance_vector}
        
        # Process updates
        any_updated = False
        for name in network:
            router = network[name]
            for neighbor in router.neighbors:
                if neighbor in all_updates:
                    updated = router.update_distance_vector(neighbor, all_updates[neighbor])
                    if updated:
                        any_updated = True
        
        # Compute routing tables
        for router in network.values():
            if router.compute_routing_table():
                converged = False
        
        if converged and not any_updated:
            break
        
        time_step += 1
    
    # Print final routing tables
    for name in sorted(network):
        router = network[name]
        print(f"Routing Table of router {name}:")
        for dest in sorted(router.routing_table):
            next_hop, cost = router.routing_table[dest]
            if cost == INF:
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{next_hop},{cost}")
        print()

if __name__ == "__main__":
    main()
