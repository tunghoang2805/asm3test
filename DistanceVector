#!/usr/bin/env python3
import sys

INF = float('inf')

def read_topology():
    nodes = []
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "START":
            break
        nodes.append(line)
    return nodes

def read_edges():
    edges = []
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "UPDATE":
            break
        a, b, w = line.split()
        edges.append((a, b, int(w)))
    return edges

def read_updates():
    updates = []
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "END":
            break
        a, b, w = line.split()
        updates.append((a, b, int(w)))
    return updates

def init_graph(nodes, edges):
    graph = {n:{} for n in nodes}
    for a, b, w in edges:
        graph[a][b] = w
        graph[b][a] = w
    return graph

def add_update_to_graph(graph, nodes, a, b, w):
    if a not in graph:
        graph[a] = {}
        nodes.append(a)
    if b not in graph:
        graph[b] = {}
        nodes.append(b)
    if w == -1:
        graph[a].pop(b, None)
        graph[b].pop(a, None)
    else:
        graph[a][b] = w
        graph[b][a] = w

def sorted_nodes(nodes, exclude=None):
    return sorted([n for n in nodes if n != exclude])

def print_distance_table(router, nodes, table, t):
    others = sorted_nodes(nodes, exclude=router)
    print(f"Distance Table of router {router} at t={t}:")
    if not others:
        print()
        return
    print('\t' + '\t'.join(others))
    for via in others:
        row = [via]
        for dest in others:
            cost = table[router][dest][via]
            row.append("INF" if cost == INF else str(int(cost)))
        print('\t'.join(row))
    print()

def print_routing_table(router, nodes, table):
    print(f"Routing Table of router {router}:")
    others = sorted_nodes(nodes, exclude=router)
    for dest in others:
        cost, nhop = get_best_route(table, router, dest)
        if nhop is None or cost == INF:
            print(f"{dest},INF,INF")
        else:
            print(f"{dest},{nhop},{int(cost)}")
    print()

def get_best_route(table, router, dest):
    mincost = INF
    minnhop = None
    for nhop in table[router][dest]:
        cost = table[router][dest][nhop]
        if cost < mincost or (cost == mincost and (minnhop is None or nhop < minnhop)):
            mincost = cost
            minnhop = nhop
    return mincost, minnhop

def initialize_tables(nodes, graph):
    table = {}
    for r in nodes:
        table[r] = {}
        others = sorted_nodes(nodes, exclude=r)
        for dest in others:
            table[r][dest] = {}
            for nhop in others:
                if nhop == dest and nhop in graph[r]:
                    table[r][dest][nhop] = graph[r][nhop]
                else:
                    table[r][dest][nhop] = INF
    return table

def dv_round(nodes, graph, table):
    updated = False
    new_table = {}
    for r in nodes:
        new_table[r] = {}
        others = sorted_nodes(nodes, exclude=r)
        for dest in others:
            new_table[r][dest] = {}
            for nhop in others:
                if nhop in graph[r]:
                    # Bellman-Ford: c(x,v) + min_w D_v(w)
                    if dest == nhop:
                        cost = graph[r][nhop]
                    else:
                        # Find best cost from nhop to dest (via any neighbor)
                        cost = graph[r][nhop]
                        # Find best cost from nhop to dest (via any neighbor of nhop)
                        best = INF
                        for nhop2 in sorted_nodes(nodes, exclude=nhop):
                            best = min(best, table[nhop][dest][nhop2])
                        cost += best
                    new_table[r][dest][nhop] = cost
                else:
                    new_table[r][dest][nhop] = INF
    # Check if updated
    for r in nodes:
        for dest in sorted_nodes(nodes, exclude=r):
            for nhop in sorted_nodes(nodes, exclude=r):
                if abs(new_table[r][dest][nhop] - table[r][dest][nhop]) > 1e-6:
                    updated = True
    return new_table, updated

def run_dv(nodes, graph):
    table = initialize_tables(nodes, graph)
    t = 0
    # Print t=0
    for r in sorted(nodes):
        print_distance_table(r, nodes, table, t)
    t += 1
    while True:
        new_table, updated = dv_round(nodes, graph, table)
        if not updated:
            break
        table = new_table
        for r in sorted(nodes):
            print_distance_table(r, nodes, table, t)
        t += 1
    for r in sorted(nodes):
        print_routing_table(r, nodes, table)

def main():
    nodes = read_topology()
    edges = read_edges()
    graph = init_graph(nodes, edges)
    run_dv(nodes.copy(), graph)
    # Process updates
    updates = read_updates()
    if not updates:
        return
    for a, b, w in updates:
        add_update_to_graph(graph, nodes, a, b, w)
    run_dv(nodes.copy(), graph)

if __name__ == "__main__":
    main()
