#!/usr/bin/env python3
import sys
from collections import defaultdict

INF = float('inf')

class Graph:
    def __init__(self):
        self.vertex_dict = {}
    
    def add_edge(self, v1, v2, weight):
        if weight == -1:
            self.remove_edge(v1, v2)
            return
        if v1 not in self.vertex_dict:
            self.vertex_dict[v1] = {}
        if v2 not in self.vertex_dict:
            self.vertex_dict[v2] = {}
        self.vertex_dict[v1][v2] = weight
        self.vertex_dict[v2][v1] = weight
    
    def remove_edge(self, v1, v2):
        if v1 in self.vertex_dict and v2 in self.vertex_dict[v1]:
            del self.vertex_dict[v1][v2]
        if v2 in self.vertex_dict and v1 in self.vertex_dict[v2]:
            del self.vertex_dict[v2][v1]
    
    def get_neighbors(self, v):
        return self.vertex_dict.get(v, {})
    
    def get_routers(self):
        return sorted(self.vertex_dict.keys())

class Router:
    def __init__(self, name, graph):
        self.name = name
        self.graph = graph
        self.distance_vector = defaultdict(lambda: defaultdict(lambda: INF))
        self.routing_table = {}
    
    def initialize(self):
        neighbors = self.graph.get_neighbors(self.name)
        for dest in self.graph.get_routers():
            if dest == self.name:
                self.distance_vector[self.name][dest] = 0
            else:
                self.distance_vector[dest][dest] = neighbors.get(dest, INF)
    
    def update_distance_vector(self):
        updated = False
        current_dv = self.get_current_dv()
        
        for neighbor in self.graph.get_neighbors(self.name):
            neighbor_dv = self.get_neighbor_dv(neighbor)
            for dest in self.graph.get_routers():
                if dest == self.name:
                    continue
                
                new_cost = self.graph.get_neighbors(self.name)[neighbor] + neighbor_dv.get(dest, INF)
                current_cost = self.distance_vector[dest].get(neighbor, INF)
                
                if new_cost < current_cost:
                    self.distance_vector[dest][neighbor] = new_cost
                    updated = True
        
        return updated
    
    def get_current_dv(self):
        return {dest: min(self.distance_vector[dest].values()) for dest in self.distance_vector}
    
    def get_neighbor_dv(self, neighbor):
        return {dest: min(self.distance_vector[dest].values()) for dest in self.distance_vector}
    
    def compute_routing_table(self):
        updated = False
        for dest in self.graph.get_routers():
            if dest == self.name:
                continue
            
            min_cost = INF
            next_hop = None
            
            for neighbor in self.distance_vector[dest]:
                if self.distance_vector[dest][neighbor] < min_cost:
                    min_cost = self.distance_vector[dest][neighbor]
                    next_hop = neighbor
            
            if min_cost == INF:
                next_hop = 'INF'
                min_cost = 'INF'
            
            current_entry = self.routing_table.get(dest, (None, INF))
            if (next_hop, min_cost) != current_entry:
                self.routing_table[dest] = (next_hop, min_cost)
                updated = True
        
        return updated

def process_input():
    routers = []
    graph = Graph()
    
    # Read routers
    while True:
        line = sys.stdin.readline().strip()
        if line == 'START':
            break
        if line:
            routers.append(line)
            graph.vertex_dict[line] = {}
    
    # Read initial links
    while True:
        line = sys.stdin.readline().strip()
        if line == 'UPDATE':
            break
        if line:
            parts = line.split()
            if len(parts) >= 3:
                v1, v2, weight = parts[0], parts[1], int(parts[2])
                graph.add_edge(v1, v2, weight)
    
    # Read updates
    updates = []
    while True:
        line = sys.stdin.readline().strip()
        if line == 'END':
            break
        if line:
            parts = line.split()
            if len(parts) >= 3:
                updates.append((parts[0], parts[1], int(parts[2])))
    
    return graph, updates

def simulate_dv(graph, updates=None):
    routers = {name: Router(name, graph) for name in graph.get_routers()}
    for router in routers.values():
        router.initialize()
    
    time_step = 0
    while True:
        # Print distance tables
        for router_name in sorted(routers):
            router = routers[router_name]
            print(f"Distance Table of router {router_name} at t={time_step}:")
            others = sorted([r for r in graph.get_routers() if r != router_name])
            print("    " + "   ".join(others))
            
            for dest in sorted(graph.get_routers()):
                if dest == router_name:
                    continue
                costs = []
                for neighbor in others:
                    cost = router.distance_vector[dest].get(neighbor, INF)
                    costs.append(str(cost) if cost != INF else "INF")
                print(f"{dest}  " + "  ".join(costs))
            print()
        
        # Check convergence
        converged = True
        for router in routers.values():
            if router.update_distance_vector():
                converged = False
            if router.compute_routing_table():
                converged = False
        
        if converged:
            break
        
        time_step += 1
    
    # Print routing tables
    for router_name in sorted(routers):
        router = routers[router_name]
        print(f"Routing Table of router {router_name}:")
        for dest in sorted(graph.get_routers()):
            if dest == router_name:
                continue
            next_hop, cost = router.routing_table.get(dest, ('INF', 'INF'))
            print(f"{dest},{next_hop},{cost}")
        print()
    
    return routers

def main():
    graph, updates = process_input()
    
    # Initial simulation
    print("Initial network configuration:")
    simulate_dv(graph)
    
    # Process updates
    for update in updates:
        v1, v2, weight = update
        graph.add_edge(v1, v2, weight)
    
    if updates:
        print("\nAfter topology updates:")
        simulate_dv(graph)

if __name__ == "__main__":
    main()
