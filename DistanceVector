import sys
from collections import defaultdict

class DistanceVectorRouter:
    def __init__(self):
        self.routers = set()
        self.topology = defaultdict(dict)  # topology[router1][router2] = cost
        self.distance_tables = {}  # distance_tables[router][dest][next_hop] = cost
        self.routing_tables = {}   # routing_tables[router][dest] = (next_hop, cost)
        
    def add_router(self, name):
        """Add a router to the network"""
        self.routers.add(name)
        if name not in self.distance_tables:
            self.distance_tables[name] = defaultdict(dict)
        if name not in self.routing_tables:
            self.routing_tables[name] = {}
    
    def add_link(self, router1, router2, cost):
        """Add or update a link between two routers"""
        if cost == -1:
            # Remove link
            if router1 in self.topology and router2 in self.topology[router1]:
                del self.topology[router1][router2]
            if router2 in self.topology and router1 in self.topology[router2]:
                del self.topology[router2][router1]
        else:
            # Add/update link
            self.add_router(router1)
            self.add_router(router2)
            self.topology[router1][router2] = cost
            self.topology[router2][router1] = cost
    
    def initialize_distance_tables(self):
        """Initialize distance tables for all routers"""
        for router in self.routers:
            self.distance_tables[router] = defaultdict(dict)
            for dest in self.routers:
                if dest != router:
                    for next_hop in self.routers:
                        if next_hop != router:
                            if next_hop in self.topology[router]:
                                if next_hop == dest:
                                    # Direct connection
                                    self.distance_tables[router][dest][next_hop] = self.topology[router][next_hop]
                                else:
                                    # Initialize to infinity for non-direct connections
                                    self.distance_tables[router][dest][next_hop] = float('inf')
                            else:
                                # No direct connection to next_hop
                                self.distance_tables[router][dest][next_hop] = float('inf')
    
    def get_distance_vector(self, router):
        """Get the distance vector for a router (minimum distances to all destinations)"""
        vector = {}
        for dest in self.routers:
            if dest != router:
                min_cost = float('inf')
                for next_hop in self.distance_tables[router][dest]:
                    if self.distance_tables[router][dest][next_hop] < min_cost:
                        min_cost = self.distance_tables[router][dest][next_hop]
                vector[dest] = min_cost
        return vector
    
    def update_distance_table(self, router, neighbor, neighbor_vector):
        """Update distance table based on neighbor's distance vector"""
        if neighbor not in self.topology[router]:
            return False
        
        changed = False
        link_cost = self.topology[router][neighbor]
        
        for dest in neighbor_vector:
            if dest != router:  # Don't update route to self
                new_cost = link_cost + neighbor_vector[dest]
                old_cost = self.distance_tables[router][dest].get(neighbor, float('inf'))
                
                if new_cost != old_cost:
                    self.distance_tables[router][dest][neighbor] = new_cost
                    changed = True
        
        return changed
    
    def print_distance_table(self, router, step):
        """Print distance table for a router at given step"""
        print(f"Distance Table of router {router} at t={step}:")
        
        # Get sorted list of other routers
        other_routers = sorted([r for r in self.routers if r != router])
        
        if not other_routers:
            print()
            return
        
        # Print header
        header = "  " + "   ".join(other_routers)
        print(header)
        
        # Print rows
        for dest in other_routers:
            row = f"{dest} "
            for next_hop in other_routers:
                cost = self.distance_tables[router][dest].get(next_hop, float('inf'))
                cost_str = "INF" if cost == float('inf') else str(cost)
                row += f"{cost_str:<3} "
            print(row.rstrip())
        
        print()  # Blank line
    
    def update_routing_table(self, router):
        """Update routing table based on current distance table"""
        self.routing_tables[router] = {}
        
        for dest in self.routers:
            if dest != router:
                min_cost = float('inf')
                best_next_hop = None
                
                # Find the best next hop (minimum cost, then alphabetical)
                next_hops = sorted(self.distance_tables[router][dest].keys())
                for next_hop in next_hops:
                    cost = self.distance_tables[router][dest][next_hop]
                    if cost < min_cost:
                        min_cost = cost
                        best_next_hop = next_hop
                
                if best_next_hop is not None:
                    self.routing_tables[router][dest] = (best_next_hop, min_cost)
                else:
                    self.routing_tables[router][dest] = ("INF", float('inf'))
    
    def print_routing_table(self, router):
        """Print routing table for a router"""
        print(f"Routing Table of router {router}:")
        
        destinations = sorted([r for r in self.routers if r != router])
        for dest in destinations:
            if dest in self.routing_tables[router]:
                next_hop, cost = self.routing_tables[router][dest]
                if cost == float('inf'):
                    print(f"{dest},INF,INF")
                else:
                    print(f"{dest},{next_hop},{cost}")
            else:
                print(f"{dest},INF,INF")
        
        print()  # Blank line
    
    def run_algorithm(self):
        """Run the distance vector algorithm until convergence"""
        if not self.routers:
            return
        
        self.initialize_distance_tables()
        step = 0
        
        while True:
            # Print distance tables for current step
            for router in sorted(self.routers):
                self.print_distance_table(router, step)
            
            # Exchange distance vectors and update tables
            changed = False
            
            for router in self.routers:
                router_vector = self.get_distance_vector(router)
                
                # Send vector to all neighbors
                for neighbor in self.topology[router]:
                    if self.update_distance_table(neighbor, router, router_vector):
                        changed = True
            
            step += 1
            
            # Check for convergence
            if not changed:
                break
        
        # Update and print final routing tables
        for router in sorted(self.routers):
            self.update_routing_table(router)
            self.print_routing_table(router)

def main():
    dv = DistanceVectorRouter()
    
    # Read router names
    while True:
        line = input().strip()
        if line == "START":
            break
        dv.add_router(line)
    
    # Read initial topology
    while True:
        line = input().strip()
        if line == "UPDATE":
            break
        parts = line.split()
        router1, router2, cost = parts[0], parts[1], int(parts[2])
        dv.add_link(router1, router2, cost)
    
    # Run algorithm for initial topology
    dv.run_algorithm()
    
    # Read updates
    has_updates = False
    while True:
        line = input().strip()
        if line == "END":
            break
        has_updates = True
        parts = line.split()
        router1, router2, cost = parts[0], parts[1], int(parts[2])
        dv.add_link(router1, router2, cost)
    
    # Run algorithm again if there were updates
    if has_updates:
        dv.run_algorithm()

if __name__ == "__main__":
    main()
