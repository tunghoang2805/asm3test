#!/usr/bin/env python3

import math
import sys
from collections import defaultdict

INF = math.inf

class Graph:
    def __init__(self):
        self.vertices = set()
        self.edges = defaultdict(dict)

    def add_vertex(self, v):
        self.vertices.add(v)

    def add_edge(self, v1, v2, weight):
        if weight == -1:
            self.remove_edge(v1, v2)
            return
        self.vertices.update([v1, v2])
        self.edges[v1][v2] = weight
        self.edges[v2][v1] = weight

    def remove_edge(self, v1, v2):
        if v2 in self.edges.get(v1, {}):
            del self.edges[v1][v2]
        if v1 in self.edges.get(v2, {}):
            del self.edges[v2][v1]

    def get_neighbors(self, v):
        return self.edges.get(v, {}).keys()

class Router:
    def __init__(self, router_id):
        self.router_id = router_id
        self.distance_table = {}
        self.routing_table = {}
        self.changed = False

    def init_distance_table(self, all_routers, graph):
        self.distance_table = defaultdict(dict)
        neighbors = graph.get_neighbors(self.router_id)
        
        for dest in sorted(all_routers):
            if dest == self.router_id:
                continue
            for neighbor in sorted(neighbors):
                if dest == neighbor:
                    self.distance_table[dest][neighbor] = graph.edges[self.router_id][neighbor]
                else:
                    self.distance_table[dest][neighbor] = INF
        self.changed = True

    def update_distance_vector(self, sender, sender_dv):
        updated = False
        current_cost = self.get_link_cost(sender)
        
        for dest in self.distance_table:
            if dest == self.router_id:
                continue
            
            old_cost = self.get_best_cost(dest)
            new_cost = current_cost + sender_dv.get(dest, INF)
            
            if new_cost < self.distance_table[dest].get(sender, INF):
                self.distance_table[dest][sender] = new_cost
                if new_cost < old_cost:
                    updated = True
        
        if updated:
            self.changed = True
            self.update_routing_table()

    def get_link_cost(self, neighbor):
        return self.distance_table.get(neighbor, {}).get(neighbor, INF)

    def get_best_cost(self, dest):
        return min(self.distance_table.get(dest, {}).values(), default=INF)

    def get_distance_vector(self):
        return {dest: self.get_best_cost(dest) for dest in self.distance_table}

    def update_routing_table(self):
        new_routing_table = {}
        for dest in sorted(self.distance_table):
            min_cost = INF
            next_hop = None
            
            for neighbor in sorted(self.distance_table[dest]):
                cost = self.distance_table[dest][neighbor]
                if cost < min_cost:
                    min_cost = cost
                    next_hop = neighbor
            
            new_routing_table[dest] = (next_hop, min_cost) if min_cost != INF else ('INF', 'INF')
        
        if new_routing_table != self.routing_table:
            self.routing_table = new_routing_table
            self.changed = True

    def print_distance_table(self, time_step):
        print(f"Distance Table of router {self.router_id} at t={time_step}:")
        destinations = sorted(self.distance_table.keys())
        neighbors = sorted(set().union(*[self.distance_table[d].keys() for d in destinations]))
        
        if not neighbors:
            print()
            return
        
        print('\t' + '\t'.join(neighbors))
        for dest in destinations:
            costs = [str(int(self.distance_table[dest].get(n, INF))) if self.distance_table[dest].get(n, INF) != INF else 'INF' 
                    for n in neighbors]
            print(f"{dest}\t" + '\t'.join(costs))
        print()

    def print_routing_table(self):
        print(f"Routing Table of router {self.router_id}:")
        for dest in sorted(self.routing_table):
            next_hop, cost = self.routing_table[dest]
            print(f"{dest},{next_hop},{int(cost) if cost != INF else 'INF'}")
        print()

class Network:
    def __init__(self, graph, routers):
        self.graph = graph
        self.routers = {r: Router(r) for r in routers}
        self.time_step = 0
        self.initialize_routers()

    def initialize_routers(self):
        all_routers = sorted(self.graph.vertices)
        for router in self.routers.values():
            router.init_distance_table(all_routers, self.graph)

    def run_convergence(self):
        changed = True
        while changed:
            changed = False
            dvs = {rid: r.get_distance_vector() for rid, r in self.routers.items()}
            
            for router in self.routers.values():
                neighbors = self.graph.get_neighbors(router.router_id)
                for neighbor in neighbors:
                    if neighbor in self.routers:
                        router.update_distance_vector(neighbor, dvs[neighbor])
                
                if router.changed:
                    changed = True
                    router.changed = False
            
            if changed:
                self.print_all_tables()
                self.time_step += 1

        self.print_routing_tables()

    def print_all_tables(self):
        for rid in sorted(self.routers):
            self.routers[rid].print_distance_table(self.time_step)

    def print_routing_tables(self):
        for rid in sorted(self.routers):
            self.routers[rid].print_routing_table()

def main():
    graph = Graph()
    routers = []
    current_section = 'routers'
    
    for line in sys.stdin:
        line = line.strip()
        if not line:
            continue
        
        if line == 'START':
            current_section = 'topology'
            continue
        elif line == 'UPDATE':
            current_section = 'update'
            network = Network(graph, routers)
            network.run_convergence()
            continue
        elif line == 'END':
            if current_section == 'update':
                network = Network(graph, routers)
                network.run_convergence()
            break
        
        if current_section == 'routers':
            routers.append(line)
            graph.add_vertex(line)
        elif current_section == 'topology':
            parts = line.split()
            if len(parts) == 3:
                v1, v2, weight = parts
                graph.add_edge(v1, v2, int(weight))
        elif current_section == 'update':
            parts = line.split()
            if len(parts) == 3:
                v1, v2, weight = parts
                graph.add_edge(v1, v2, int(weight))
                if v1 not in routers:
                    routers.append(v1)
                if v2 not in routers:
                    routers.append(v2)

if __name__ == "__main__":
    main()
