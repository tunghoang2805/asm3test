#!/usr/bin/env python3

import sys
import math

INF = math.inf

class Graph:
    # Represents a network graph with weighted edges between routers.
    def __init__(self):
        self.vertex_dict = {}
    def add_edge(self, v1, v2, weight):
        # Add a bidirectional weighted edge between two routers.
        if v1 not in self.vertex_dict:
            self.vertex_dict[v1] = {}
        if v2 not in self.vertex_dict:
            self.vertex_dict[v2] = {}
        self.vertex_dict[v1][v2] = weight
        self.vertex_dict[v2][v1] = weight
    def remove_edge(self, v1, v2):
        # Remove the edge between two routers.
        if v1 not in self.vertex_dict or v2 not in self.vertex_dict:
            return
        if v2 in self.vertex_dict[v1]:
            del self.vertex_dict[v1][v2]
        if v1 in self.vertex_dict[v2]:
            del self.vertex_dict[v2][v1]
    def get_neighbors(self, v):
        # Get all neighbors of a router.
        return self.vertex_dict.get(v, {})

class Router:
    def __init__(self, identifier):
        self.router_id = identifier
        self.distance_table = {}
        self.pending_updates = []
        self.routing_table = {}
        self.needs_update = False

    def init_distance_table(self, all_nodes):
        nodes = [n for n in all_nodes if n != self.router_id]
        self.distance_table = {
            dest: {node: INF for node in nodes}
            for dest in nodes
        }

    def update_self_state(self, graph, routers):
        neighbors = graph.get_neighbors(self.router_id)
        for adj_router in neighbors:
            self.distance_table[adj_router][adj_router] = graph.vertex_dict[self.router_id][adj_router]
        
        for rtr in routers:
            if rtr.router_id not in neighbors and rtr.router_id != self.router_id:
                for dest in self.distance_table:
                    self.distance_table[dest][rtr.router_id] = INF
        self.needs_update = True

    def propagate_updates(self, neighbors, routers):
        if not self.needs_update:
            return
            
        for rtr in routers:
            if rtr.router_id in neighbors:
                # Manual deep copy replacement
                copied_table = {
                    dest: {via: cost for via, cost in via_dict.items()}
                    for dest, via_dict in self.distance_table.items()
                }
                rtr.pending_updates.append((self.router_id, copied_table))
        self.needs_update = False

    def process_updates(self):
        for src_router, received_table in self.pending_updates:
            for dest in self.distance_table:
                if dest == src_router:
                    continue
                
                current_cost = self.distance_table[dest].get(src_router, INF)
                link_cost = self.distance_table[src_router][src_router]
                new_cost = link_cost + min(received_table[dest].values())
                
                if new_cost < current_cost:
                    self.distance_table[dest][src_router] = new_cost
                    self.needs_update = True
        self.pending_updates = []

    def build_routing_table(self):
        self.routing_table.clear()
        for dest in self.distance_table:
            min_cost = INF
            best_hop = None
            for via in self.distance_table[dest]:
                if self.distance_table[dest][via] < min_cost:
                    min_cost = self.distance_table[dest][via]
                    best_hop = via
            self.routing_table[dest] = (best_hop, min_cost)

    def display_distance_table(self, time_step):
        print(f"Distance Table of router {self.router_id} at t={time_step}:")
        nodes = sorted(self.distance_table.keys())
        header = [''] + nodes
        print('\t'.join(header))
        for dest in nodes:
            row = [dest] + [str(self.distance_table[dest][n]).replace('inf', 'INF') for n in nodes]
            print('\t'.join(row))
        print()

    def display_routing_table(self):
        self.build_routing_table()
        print(f"Routing Table of router {self.router_id}:")
        for dest in sorted(self.routing_table):
            print(f"{dest},{self.routing_table[dest][0]},{self.routing_table[dest][1]}")
        print()

def main():
    network = Graph()
    routers = []
    
    # Read initial topology
    while (line := sys.stdin.readline().strip()) != "START":
        network.vertex_dict[line] = {}
        routers.append(Router(line))
    
    # Add edges
    while (line := sys.stdin.readline().strip()) != "UPDATE":
        v1, v2, w = line.split()
        network.add_edge(v1, v2, int(w))
    
    # Initialize routers
    node_names = list(network.vertex_dict.keys())
    for rtr in routers:
        rtr.init_distance_table(node_names)
        rtr.update_self_state(network, routers)
    
    # Initial state display
    for rtr in routers:
        rtr.display_distance_table(0)
    
    # Convergence loop
    time_step = 1
    prev_tables = {rtr.router_id: rtr.distance_table for rtr in routers}
    while True:
        # Exchange updates
        for rtr in routers:
            rtr.propagate_updates(network.get_neighbors(rtr.router_id), routers)
        for rtr in routers:
            rtr.process_updates()
        
        # Check stabilization
        if all(rtr.distance_table == prev_tables[rtr.router_id] for rtr in routers):
            break
        
        # Display current state
        for rtr in routers:
            rtr.display_distance_table(time_step)
        
        # Update previous tables
        prev_tables = {rtr.router_id: {dest: dict(via) for dest, via in rtr.distance_table.items()} for rtr in routers}
        time_step += 1
    
    # Final routing tables
    for rtr in routers:
        rtr.display_routing_table()
    
    # Handle topology updates
    while (line := sys.stdin.readline().strip()) != "END":
        v1, v2, w = line.split()
        if int(w) == -1:
            network.remove_edge(v1, v2)
        else:
            network.add_edge(v1, v2, int(w))
        
        # Update router states
        prev_tables = {rtr.router_id: {dest: dict(via) for dest, via in rtr.distance_table.items()} for rtr in routers}
        for rtr in routers:
            rtr.update_self_state(network, routers)
        
        # Process changes
        time_step += 1
        while True:
            for rtr in routers:
                rtr.propagate_updates(network.get_neighbors(rtr.router_id), routers)
            for rtr in routers:
                rtr.process_updates()
            
            if all(rtr.distance_table == prev_tables[rtr.router_id] for rtr in routers):
                break
            
            for rtr in routers:
                rtr.display_distance_table(time_step)
            
            prev_tables = {rtr.router_id: {dest: dict(via) for dest, via in rtr.distance_table.items()} for rtr in routers}
            time_step += 1
        
        for rtr in routers:
            rtr.display_routing_table()

if __name__ == "__main__":
    main()
