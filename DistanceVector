#!/usr/bin/env python3

import sys
import math

INF = math.inf

class Graph:
    # Represents a network graph with weighted edges between routers.
    def __init__(self):
        self.vertex_dict = {}
    def add_edge(self, v1, v2, weight):
        # Add a bidirectional weighted edge between two routers.
        if v1 not in self.vertex_dict:
            self.vertex_dict[v1] = {}
        if v2 not in self.vertex_dict:
            self.vertex_dict[v2] = {}
        self.vertex_dict[v1][v2] = weight
        self.vertex_dict[v2][v1] = weight
    def remove_edge(self, v1, v2):
        # Remove the edge between two routers.
        if v1 not in self.vertex_dict or v2 not in self.vertex_dict:
            return
        if v2 in self.vertex_dict[v1]:
            del self.vertex_dict[v1][v2]
        if v1 in self.vertex_dict[v2]:
            del self.vertex_dict[v2][v1]
    def get_neighbors(self, v):
        # Get all neighbors of a router.
        return self.vertex_dict.get(v, {})



class Router:
    def __init__(self, name):
        self.name = name
        self.distance_table = {}
        self.routing_table = {}
        self.pending_updates = []
        self.changed = False

    def initialize(self, nodes):
        # Initialize distance table with infinite cost except to self
        for dest in nodes:
            self.distance_table[dest] = {}
            for via in nodes:
                if dest == via:
                    self.distance_table[dest][via] = 0 if dest == self.name else INF
                else:
                    self.distance_table[dest][via] = INF

    def update_neighbors_costs(self, graph):
        # Update direct neighbor costs
        neighbors = graph.get_neighbors(self.name)
        for neighbor, cost in neighbors.items():
            self.distance_table[neighbor][neighbor] = cost

    def queue_update(self, routers, graph):
        # If changed, send a deep copy of distance_table to all neighbors
        if self.changed:
            neighbors = graph.get_neighbors(self.name)
            for router in routers:
                if router.name in neighbors:
                    # Deep copy using dict comprehensions
                    update_table = {d: dict(self.distance_table[d]) for d in self.distance_table}
                    router.pending_updates.append((self.name, update_table))
            self.changed = False

    def process_updates(self):
        # Process all pending updates
        updated = False
        for sender, received_table in self.pending_updates:
            for dest in self.distance_table:
                if dest == sender:
                    continue
                cost_to_sender = self.distance_table[sender][sender]
                # Find minimum cost from sender's table to dest
                min_cost = min(received_table[dest].values())
                new_cost = cost_to_sender + min_cost
                if new_cost < self.distance_table[dest][sender]:
                    self.distance_table[dest][sender] = new_cost
                    updated = True
        self.pending_updates = []
        if updated:
            self.changed = True

    def update_routing_table(self):
        # For each destination, find the best next hop and cost
        for dest in self.distance_table:
            min_cost = INF
            next_hop = None
            for via, cost in self.distance_table[dest].items():
                if cost < min_cost:
                    min_cost = cost
                    next_hop = via
            self.routing_table[dest] = (next_hop, min_cost)

    def print_distance_table(self):
        nodes = sorted(self.distance_table.keys())
        header = [' '] + nodes
        print('\t'.join(header))
        for dest in nodes:
            row = [dest] + [str(self.distance_table[dest][via]) if self.distance_table[dest][via] != INF else 'INF'
                            for via in nodes]
            print('\t'.join(row))

    def print_routing_table(self):
        self.update_routing_table()
        print(f"Routing Table of router {self.name}:")
        for dest in sorted(self.routing_table):
            nh, cost = self.routing_table[dest]
            print(f"{dest},{nh},{cost}")
        print()

def deep_copy_distance_tables(routers):
    # Returns a dict of router name -> deep copy of its distance_table
    return {router.name: {d: dict(router.distance_table[d]) for d in router.distance_table} for router in routers}

def distance_tables_equal(dt1, dt2):
    # Compares two sets of distance tables
    for key in dt1:
        if dt1[key] != dt2[key]:
            return False
    return True

def main():
    # Read node names
    nodes_list = []
    routers = {}
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "START":
            break
        nodes_list.append(line)
        routers[line] = Router(line)

    # Build graph
    graph = Graph()
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "UPDATE":
            break
        n1, n2, w = line.split()
        graph.add_edge(n1, n2, int(w))

    # Initialize routers
    for router in routers.values():
        router.initialize(nodes_list)
        router.update_neighbors_costs(graph)

    # Print initial tables
    for router in routers.values():
        print(f"Distance Table of router {router.name} at t=0:")
        router.print_distance_table()
        print()

    # Distance Vector Algorithm: Iterate until convergence
    t = 1
    prev_tables = deep_copy_distance_tables(routers.values())
    while True:
        # Each router queues updates to neighbors
        for router in routers.values():
            router.queue_update(routers.values(), graph)
        # Each router processes received updates
        for router in routers.values():
            router.process_updates()
        # Check convergence
        curr_tables = deep_copy_distance_tables(routers.values())
        if distance_tables_equal(prev_tables, curr_tables):
            break
        prev_tables = deep_copy_distance_tables(routers.values())
        # Print tables at this time step
        for router in routers.values():
            print(f"Distance Table of router {router.name} at t={t}:")
            router.print_distance_table()
            print()
        t += 1

    # Print routing tables
    for router in routers.values():
        router.print_routing_table()

    # Handle dynamic updates
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "END":
            break
        n1, n2, w = line.split()
        if int(w) == -1:
            graph.remove_edge(n1, n2)
        else:
            graph.add_edge(n1, n2, int(w))
        # Routers update their neighbor costs
        for router in routers.values():
            router.update_neighbors_costs(graph)
        # Repeat DV algorithm after update
        t += 1
        prev_tables = deep_copy_distance_tables(routers.values())
        while True:
            for router in routers.values():
                router.queue_update(routers.values(), graph)
            for router in routers.values():
                router.process_updates()
            curr_tables = deep_copy_distance_tables(routers.values())
            if distance_tables_equal(prev_tables, curr_tables):
                break
            prev_tables = deep_copy_distance_tables(routers.values())
            for router in routers.values():
                print(f"Distance Table of router {router.name} at t={t}:")
                router.print_distance_table()
                print()
            t += 1
        for router in routers.values():
            router.print_routing_table()

if __name__ == "__main__":
    main()
