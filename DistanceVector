#!/usr/bin/env python3

import sys
import math

INFINITY = math.inf

class Graph:
    # Represents a network graph with weighted edges between routers.
    def __init__(self):
        self.vertex_dict = {}
    def add_edge(self, v1, v2, weight):
        # Add a bidirectional weighted edge between two routers.
        if v1 not in self.vertex_dict:
            self.vertex_dict[v1] = {}
        if v2 not in self.vertex_dict:
            self.vertex_dict[v2] = {}
        self.vertex_dict[v1][v2] = weight
        self.vertex_dict[v2][v1] = weight
    def remove_edge(self, v1, v2):
        # Remove the edge between two routers.
        if v1 not in self.vertex_dict or v2 not in self.vertex_dict:
            return
        if v2 in self.vertex_dict[v1]:
            del self.vertex_dict[v1][v2]
        if v1 in self.vertex_dict[v2]:
            del self.vertex_dict[v2][v1]
    def get_neighbors(self, v):
        # Get all neighbors of a router.
        return self.vertex_dict.get(v, {})

class NetworkRouter:
    def __init__(self, router_id):
        self.router_id = router_id
        self.distance_vectors = {}
        self.pending_updates = []
        self.forwarding_table = {}
        self.needs_broadcast = False

    def setup_distance_vectors(self, all_nodes):
        # Initialize distance vectors for all destination nodes
        destinations = [node for node in all_nodes if node != self.router_id]
        
        for destination in destinations:
            self.distance_vectors[destination] = {}
            for via_node in destinations:
                self.distance_vectors[destination][via_node] = float('inf')

    def display_distance_vectors(self):
        # Print the distance vector table in tabular format
        destinations = sorted(self.distance_vectors.keys())
        header_row = [' '] + destinations
        print('\t'.join(header_row))
        
        for dest in destinations:
            values = [str(self.distance_vectors[dest][via]).replace('inf', 'INF') for via in destinations]
            row_data = [dest] + values
            print('\t'.join(row_data))

    def refresh_local_distances(self, network_graph, router_list):
        # Update distances to direct neighbors
        adjacent_nodes = network_graph.get_neighbors(self.router_id)
        
        for neighbor_id in adjacent_nodes:
            direct_cost = network_graph.vertex_dict[self.router_id][neighbor_id]
            self.distance_vectors[neighbor_id][neighbor_id] = direct_cost

        # Set infinite cost for non-adjacent routers
        for router in router_list:
            if router.router_id not in adjacent_nodes and router.router_id != self.router_id:
                for dest in self.distance_vectors:
                    self.distance_vectors[dest][router.router_id] = INFINITY

        self.needs_broadcast = True

    def broadcast_to_neighbors(self, adjacent_routers, all_routers):
        # Send distance vector updates to neighboring routers
        if self.needs_broadcast:
            for router in all_routers:
                if router.router_id in adjacent_routers:
                    # Create a deep copy manually without using copy library
                    copied_vectors = {}
                    for dest in self.distance_vectors:
                        copied_vectors[dest] = {}
                        for via in self.distance_vectors[dest]:
                            copied_vectors[dest][via] = self.distance_vectors[dest][via]
                    
                    router.pending_updates.append((self.router_id, copied_vectors))
            
            self.needs_broadcast = False

    def handle_incoming_updates(self):
        # Process received distance vector updates from neighbors
        for sender_id, received_vectors in self.pending_updates:
            for destination in self.distance_vectors:
                if destination == sender_id:
                    continue
                
                for via_router in self.distance_vectors[destination]:
                    if via_router == sender_id:
                        old_distance = self.distance_vectors[destination][via_router]
                        cost_to_sender = self.distance_vectors[sender_id][sender_id]
                        min_cost_via_sender, _ = self.calculate_minimum_path(received_vectors, destination)
                        new_total_cost = cost_to_sender + min_cost_via_sender
                        
                        self.distance_vectors[destination][sender_id] = new_total_cost
                        
                        if old_distance != new_total_cost:
                            self.needs_broadcast = True

        # Clear processed updates
        self.pending_updates = []

    def build_forwarding_table(self):
        # Create routing table with next hop and minimum cost for each destination
        for destination in self.distance_vectors:
            min_cost, next_hop = self.calculate_minimum_path(self.distance_vectors, destination)
            self.forwarding_table[destination] = (next_hop, min_cost)

    def calculate_minimum_path(self, vectors, target_dest):
        # Find the minimum cost path and next hop for a destination
        minimum_cost = INFINITY
        best_next_hop = None
        
        for via_node in vectors[target_dest]:
            current_cost = vectors[target_dest][via_node]
            if current_cost < minimum_cost:
                minimum_cost = current_cost
                best_next_hop = via_node
        
        return (minimum_cost, best_next_hop)

    def display_forwarding_table(self):
        # Print the final routing table
        self.build_forwarding_table()
        print(f"Routing Table of router {self.router_id}:")
        
        for dest in sorted(self.forwarding_table.keys()):
            next_hop, cost = self.forwarding_table[dest]
            print(f"{dest},{next_hop},{cost}")
        print()

    def handle_topology_change(self, network_graph, router_list):
        # Process changes in network topology
        # Store original state manually
        original_vectors = {}
        for dest in self.distance_vectors:
            original_vectors[dest] = {}
            for via in self.distance_vectors[dest]:
                original_vectors[dest][via] = self.distance_vectors[dest][via]

        self.pending_updates = []
        self.refresh_local_distances(network_graph, router_list)

        # Update based on current routing tables of neighbors
        neighbors = network_graph.get_neighbors(self.router_id)
        for router in router_list:
            if router.router_id in neighbors:
                for dest in router.forwarding_table:
                    if dest == self.router_id:
                        continue
                    
                    cost_to_neighbor = self.distance_vectors[router.router_id][router.router_id]
                    neighbor_to_dest_cost = router.forwarding_table[dest][1]
                    total_path_cost = cost_to_neighbor + neighbor_to_dest_cost
                    
                    self.distance_vectors[dest][router.router_id] = total_path_cost

        # Check if any changes occurred
        vectors_changed = False
        for dest in self.distance_vectors:
            for via in self.distance_vectors[dest]:
                if self.distance_vectors[dest][via] != original_vectors[dest][via]:
                    vectors_changed = True
                    break
            if vectors_changed:
                break

        if vectors_changed:
            self.needs_broadcast = True

def main():
    node_names = []
    network = Graph()

    # Read router names
    input_line = sys.stdin.readline().strip()
    while input_line != "START":
        node_names.append(input_line)
        router_instance = NetworkRouter(input_line)
        network.vertex_dict[router_instance.router_id] = {}
        input_line = sys.stdin.readline().strip()

    # Read network topology
    input_line = sys.stdin.readline().strip()
    while input_line != "UPDATE":
        vertex1, vertex2, edge_weight = input_line.split()
        network.add_edge(vertex1, vertex2, int(edge_weight))
        input_line = sys.stdin.readline().strip()

    # Initialize all routers
    router_instances = []
    for node_name in node_names:
        router = NetworkRouter(node_name)
        router.setup_distance_vectors(node_names)
        router.refresh_local_distances(network, router_instances)
        router_instances.append(router)

    # Display initial state
    for router in router_instances:
        print(f"Distance Table of router {router.router_id} at t=0:")
        router.display_distance_vectors()
        print()

    # Run convergence algorithm
    time_step = 1
    previous_state = {}
    
    # Store initial state manually
    for router in router_instances:
        previous_state[router.router_id] = {}
        for dest in router.distance_vectors:
            previous_state[router.router_id][dest] = {}
            for via in router.distance_vectors[dest]:
                previous_state[router.router_id][dest][via] = router.distance_vectors[dest][via]

    while True:
        # Broadcast phase
        for router in router_instances:
            router.broadcast_to_neighbors(network.get_neighbors(router.router_id), router_instances)

        # Update phase
        for router in router_instances:
            router.handle_incoming_updates()

        # Check convergence
        converged = True
        for router in router_instances:
            for dest in router.distance_vectors:
                for via in router.distance_vectors[dest]:
                    if router.distance_vectors[dest][via] != previous_state[router.router_id][dest][via]:
                        converged = False
                        break
                if not converged:
                    break
            if not converged:
                break

        if converged:
            break

        # Store current state manually
        previous_state = {}
        for router in router_instances:
            previous_state[router.router_id] = {}
            for dest in router.distance_vectors:
                previous_state[router.router_id][dest] = {}
                for via in router.distance_vectors[dest]:
                    previous_state[router.router_id][dest][via] = router.distance_vectors[dest][via]

        # Display current state
        for router in router_instances:
            print(f"Distance Table of router {router.router_id} at t={time_step}:")
            router.display_distance_vectors()
            print()

        time_step += 1

        # Check if no more updates needed
        if all(not router.needs_broadcast for router in router_instances):
            break

    # Display final routing tables
    for router in router_instances:
        router.display_forwarding_table()

    # Handle topology updates
    while True:
        input_line = sys.stdin.readline().strip()
        if input_line == "END":
            break

        vertex1, vertex2, edge_weight = input_line.split()
        if int(edge_weight) == -1:
            network.remove_edge(vertex1, vertex2)
        else:
            network.add_edge(vertex1, vertex2, int(edge_weight))

        # Store state before topology change
        pre_change_state = {}
        for router in router_instances:
            pre_change_state[router.router_id] = {}
            for dest in router.distance_vectors:
                pre_change_state[router.router_id][dest] = {}
                for via in router.distance_vectors[dest]:
                    pre_change_state[router.router_id][dest][via] = router.distance_vectors[dest][via]

        # Process topology change
        for router in router_instances:
            router.handle_topology_change(network, router_instances)

        # Check if anything changed
        no_changes = True
        for router in router_instances:
            for dest in router.distance_vectors:
                for via in router.distance_vectors[dest]:
                    if router.distance_vectors[dest][via] != pre_change_state[router.router_id][dest][via]:
                        no_changes = False
                        break
                if not no_changes:
                    break
            if not no_changes:
                break

        if no_changes:
            sys.exit()

        # Display state after topology change
        for router in router_instances:
            print(f"Distance Table of router {router.router_id} at t={time_step}:")
            router.display_distance_vectors()
            print()

        time_step += 1

        # Store current state
        previous_state = {}
        for router in router_instances:
            previous_state[router.router_id] = {}
            for dest in router.distance_vectors:
                previous_state[router.router_id][dest] = {}
                for via in router.distance_vectors[dest]:
                    previous_state[router.router_id][dest][via] = router.distance_vectors[dest][via]

        # Continue convergence after topology change
        while True:
            # Broadcast phase
            for router in router_instances:
                router.broadcast_to_neighbors(network.get_neighbors(router.router_id), router_instances)

            # Update phase
            for router in router_instances:
                router.handle_incoming_updates()

            # Check convergence
            converged = True
            for router in router_instances:
                for dest in router.distance_vectors:
                    for via in router.distance_vectors[dest]:
                        if router.distance_vectors[dest][via] != previous_state[router.router_id][dest][via]:
                            converged = False
                            break
                    if not converged:
                        break
                if not converged:
                    break

            if converged:
                break

            # Store current state
            previous_state = {}
            for router in router_instances:
                previous_state[router.router_id] = {}
                for dest in router.distance_vectors:
                    previous_state[router.router_id][dest] = {}
                    for via in router.distance_vectors[dest]:
                        previous_state[router.router_id][dest][via] = router.distance_vectors[dest][via]

            # Display current state
            for router in router_instances:
                print(f"Distance Table of router {router.router_id} at t={time_step}:")
                router.display_distance_vectors()
                print()

            time_step += 1

            # Check if no more updates needed
            if all(not router.needs_broadcast for router in router_instances):
                break

        # Display final routing tables after convergence
        for router in router_instances:
            router.display_forwarding_table()

if __name__ == "__main__":
    main()
