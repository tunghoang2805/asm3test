#!/usr/bin/env python3

import sys
import copy

class Graph:
    def __init__(self):
        self.adj_list = {}
    
    def add_edge(self, node1, node2, weight):
        if node1 not in self.adj_list:
            self.adj_list[node1] = {}
        if node2 not in self.adj_list:
            self.adj_list[node2] = {}
        self.adj_list[node1][node2] = weight
        self.adj_list[node2][node1] = weight
    
    def remove_edge(self, node1, node2):
        if node1 not in self.adj_list or node2 not in self.adj_list:
            return
        if node2 in self.adj_list[node1]:
            del self.adj_list[node1][node2]
        if node1 in self.adj_list[node2]:
            del self.adj_list[node2][node1]
    
    def get_neighbors(self, node):
        return self.adj_list.get(node, {})

class Router:
    def __init__(self, name):
        self._name = name
        self.distance_table = {}  # distance_table[dest][via] = cost
        self.updates_to_process = []  # List of (source, distance_table) tuples
        self.routing_table = {}
        self.update_neighbors = False
    
    def initialize_distance_table(self, nodes):
        """Initialize distance table with all destinations and via nodes"""
        nodes = [n for n in nodes if n != self._name]
        
        for dest in nodes:
            self.distance_table[dest] = {}
            for via in nodes:
                self.distance_table[dest][via] = float('inf')
    
    def update_self(self, graph, routers_list):
        """Update distance table with direct neighbor costs"""
        neighbors = graph.get_neighbors(self._name)
        
        # Set direct neighbor costs
        for neighbor, cost in neighbors.items():
            if neighbor in self.distance_table:
                self.distance_table[neighbor][neighbor] = cost
        
        # Set infinite cost for non-neighbors
        for router in routers_list:
            if router._name not in neighbors and router._name != self._name:
                for dest in self.distance_table:
                    if router._name in self.distance_table[dest]:
                        self.distance_table[dest][router._name] = float('inf')
        
        self.update_neighbors = True
    
    def send_updates(self, neighbors, routers_list):
        """Send distance vector updates to neighbors"""
        if self.update_neighbors:
            for router in routers_list:
                if router._name in neighbors:
                    router.updates_to_process.append((self._name, copy.deepcopy(self.distance_table)))
            self.update_neighbors = False
    
    def process_received_tables(self):
        """Process received distance vectors using Bellman-Ford equation"""
        for update in self.updates_to_process:
            received_from = update[0]
            received_distance_table = update[1]
            
            for dest in self.distance_table:
                if dest == received_from:
                    continue
                
                if received_from in self.distance_table[dest]:
                    previous_cost = self.distance_table[dest][received_from]
                    
                    # Calculate cost via received_from: c(x,v) + D_v(y)
                    cost_to_via = self.distance_table[received_from][received_from]
                    min_cost_from_via = self.find_min_cost(received_distance_table, dest)[0]
                    total_cost = cost_to_via + min_cost_from_via
                    
                    self.distance_table[dest][received_from] = total_cost
                    
                    if previous_cost != total_cost:
                        self.update_neighbors = True
        
        self.updates_to_process = []
    
    def find_min_cost(self, distance_table, dest):
        """Find minimum cost and next hop for a destination"""
        min_cost = float('inf')
        next_hop = None
        
        if dest not in distance_table:
            return (min_cost, next_hop)
        
        # Find minimum cost path (alphabetical tie-breaking)
        for via in sorted(distance_table[dest].keys()):
            cost = distance_table[dest][via]
            if cost < min_cost:
                min_cost = cost
                next_hop = via
        
        return (min_cost, next_hop)
    
    def create_routing_table(self):
        """Create routing table from distance table"""
        self.routing_table = {}
        for dest in self.distance_table:
            min_cost, next_hop = self.find_min_cost(self.distance_table, dest)
            self.routing_table[dest] = (next_hop, min_cost)
    
    def print_distance_table(self, step):
        """Print distance table in required format"""
        print(f"Distance Table of router {self._name} at t={step}:")
        
        if not self.distance_table:
            print()
            return
        
        nodes = sorted(self.distance_table.keys())
        
        # Print header
        header = '\t'.join([''] + nodes)
        print(header)
        
        # Print rows
        for via in nodes:
            row_values = [via]
            for dest in nodes:
                cost = self.distance_table[dest].get(via, float('inf'))
                cost_str = 'INF' if cost == float('inf') else str(int(cost))
                row_values.append(cost_str)
            print('\t'.join(row_values))
        
        print()
    
    def print_routing_table(self):
        """Print routing table in required format"""
        self.create_routing_table()
        print(f"Routing Table of router {self._name}:")
        
        for dest in sorted(self.routing_table.keys()):
            next_hop, cost = self.routing_table[dest]
            if next_hop is None or cost == float('inf'):
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{next_hop},{int(cost)}")
        
        print()
    
    def process_after_update(self, graph, routers_list):
        """Process changes after topology update"""
        original_distance_table = copy.deepcopy(self.distance_table)
        self.updates_to_process = []
        self.update_self(graph, routers_list)
        
        # Update based on current routing tables of neighbors
        neighbors = graph.get_neighbors(self._name)
        for router in routers_list:
            if router._name in neighbors:
                for dest in router.routing_table:
                    if dest == self._name:
                        continue
                    
                    cost_to_via = self.distance_table[router._name][router._name]
                    via_to_dest = router.routing_table[dest][1]
                    
                    if dest in self.distance_table and router._name in self.distance_table[dest]:
                        self.distance_table[dest][router._name] = cost_to_via + via_to_dest
        
        if self.distance_table != original_distance_table:
            self.update_neighbors = True

def main():
    nodes_list = []
    graph = Graph()
    
    # Read router names
    while True:
        line = sys.stdin.readline().strip()
        if line == "START":
            break
        nodes_list.append(line)
        graph.adj_list[line] = {}
    
    # Read initial topology
    while True:
        line = sys.stdin.readline().strip()
        if line == "UPDATE":
            break
        
        parts = line.split()
        node1, node2, weight = parts[0], parts[1], int(parts[2])
        
        if weight == -1:
            graph.remove_edge(node1, node2)
        else:
            graph.add_edge(node1, node2, weight)
    
    # Initialize routers
    routers_list = []
    for node in sorted(nodes_list):
        router = Router(node)
        router.initialize_distance_table(nodes_list)
        routers_list.append(router)
    
    # Update routers with initial topology
    for router in routers_list:
        router.update_self(graph, routers_list)
    
    # Print initial distance tables
    for router in routers_list:
        router.print_distance_table(0)
    
    # Run algorithm until convergence
    t = 1
    previous_distance_tables = {}
    for router in routers_list:
        previous_distance_tables[router._name] = copy.deepcopy(router.distance_table)
    
    while True:
        # Send updates
        for router in routers_list:
            router.send_updates(graph.get_neighbors(router._name), routers_list)
        
        # Process received updates
        for router in routers_list:
            router.process_received_tables()
        
        # Check for convergence
        converged = True
        for router in routers_list:
            if router.distance_table != previous_distance_tables[router._name]:
                converged = False
                break
        
        if converged and all(not router.update_neighbors for router in routers_list):
            break
        
        # Store current distance tables
        for router in routers_list:
            previous_distance_tables[router._name] = copy.deepcopy(router.distance_table)
        
        # Print distance tables
        for router in routers_list:
            router.print_distance_table(t)
        
        t += 1
    
    # Print final routing tables
    for router in routers_list:
        router.print_routing_table()
    
    # Handle topology updates
    while True:
        line = sys.stdin.readline().strip()
        if line == "END":
            break
        
        parts = line.split()
        node1, node2, weight = parts[0], parts[1], int(parts[2])
        
        # Add new routers if needed
        if node1 not in [r._name for r in routers_list]:
            new_router = Router(node1)
            new_router.initialize_distance_table([r._name for r in routers_list] + [node1])
            routers_list.append(new_router)
            nodes_list.append(node1)
            # Update existing routers' distance tables
            for router in routers_list[:-1]:
                router.initialize_distance_table(nodes_list)
        
        if node2 not in [r._name for r in routers_list]:
            new_router = Router(node2)
            new_router.initialize_distance_table([r._name for r in routers_list] + [node2])
            routers_list.append(new_router)
            nodes_list.append(node2)
            # Update existing routers' distance tables
            for router in routers_list[:-1]:
                router.initialize_distance_table(nodes_list)
        
        # Update topology
        if weight == -1:
            graph.remove_edge(node1, node2)
        else:
            graph.add_edge(node1, node2, weight)
        
        # Sort routers alphabetically
        routers_list.sort(key=lambda x: x._name)
        
        # Store previous distance tables
        previous_distance_tables = {}
        for router in routers_list:
            previous_distance_tables[router._name] = copy.deepcopy(router.distance_table)
        
        # Process topology changes
        for router in routers_list:
            router.process_after_update(graph, routers_list)
        
        # Check if any changes occurred
        no_changes = True
        for router in routers_list:
            if router.distance_table != previous_distance_tables[router._name]:
                no_changes = False
                break
        
        if no_changes:
            break
        
        # Print distance tables after update
        for router in routers_list:
            router.print_distance_table(t)
        
        t += 1
        
        # Store current distance tables
        for router in routers_list:
            previous_distance_tables[router._name] = copy.deepcopy(router.distance_table)
        
        # Continue algorithm until convergence
        while True:
            # Send updates
            for router in routers_list:
                router.send_updates(graph.get_neighbors(router._name), routers_list)
            
            # Process received updates
            for router in routers_list:
                router.process_received_tables()
            
            # Check for convergence
            converged = True
            for router in routers_list:
                if router.distance_table != previous_distance_tables[router._name]:
                    converged = False
                    break
            
            if converged and all(not router.update_neighbors for router in routers_list):
                break
            
            # Store current distance tables
            for router in routers_list:
                previous_distance_tables[router._name] = copy.deepcopy(router.distance_table)
            
            # Print distance tables
            for router in routers_list:
                router.print_distance_table(t)
            
            t += 1
        
        # Print final routing tables
        for router in routers_list:
            router.print_routing_table()
        
        break

if __name__ == "__main__":
    main()
